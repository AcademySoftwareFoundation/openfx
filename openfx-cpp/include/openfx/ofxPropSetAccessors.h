// Copyright OpenFX and contributors to the OpenFX project.
// SPDX-License-Identifier: BSD-3-Clause
// NOTE: This file is auto-generated by gen-props.py. DO NOT EDIT.

#pragma once

#include <array>
#include <vector>
#include "ofxPropsAccess.h"
#include "ofxPropsMetadata.h"

namespace openfx {

// Type-safe property set accessor classes for PLUGINS
//
// These wrapper classes provide convenient, type-safe access to property sets.
// - For plugins: getters for host-written properties, setters for plugin-written properties
// - For hosts: setters for host-written properties, getters for plugin-written properties
//
// Usage:
//   PropertyAccessor accessor(handle, propSuite);
//   EffectDescriptor desc(accessor);
//   desc.setLabel("My Effect");  // Type-safe setter
//   auto label = desc.label();    // Type-safe getter

// Base class for property set accessors
class PropertySetAccessor {
protected:
    PropertyAccessor& props_;
public:
    explicit PropertySetAccessor(PropertyAccessor& p) : props_(p) {}

    // Access to underlying PropertyAccessor for advanced use
    PropertyAccessor& props() { return props_; }
    const PropertyAccessor& props() const { return props_; }
};

// Property set accessor for: ActionBeginInstanceChanged_InArgs
class ActionBeginInstanceChanged_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* changeReason(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropChangeReason>(0, error_if_missing);
    }

};

// Property set accessor for: ActionEndInstanceChanged_InArgs
class ActionEndInstanceChanged_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* changeReason(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropChangeReason>(0, error_if_missing);
    }

};

// Property set accessor for: ActionInstanceChanged_InArgs
class ActionInstanceChanged_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* changeReason(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropChangeReason>(0, error_if_missing);
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

};

// Property set accessor for: ClipDescriptor
class ClipDescriptor : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ClipDescriptor& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ClipDescriptor& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ClipDescriptor& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ClipDescriptor& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ClipDescriptor& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ClipDescriptor& setSupportedComponents(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportedComponents>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ClipDescriptor& setSupportedComponents(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedComponents>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ClipDescriptor& setSupportedComponents(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedComponents>(values, error_if_missing);
        return *this;
    }

    ClipDescriptor& setTemporalClipAccess(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropTemporalClipAccess>(value, 0, error_if_missing);
        return *this;
    }

    ClipDescriptor& setOptional(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropOptional>(value, 0, error_if_missing);
        return *this;
    }

    ClipDescriptor& setFieldExtraction(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropFieldExtraction>(value, 0, error_if_missing);
        return *this;
    }

    ClipDescriptor& setIsMask(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropIsMask>(value, 0, error_if_missing);
        return *this;
    }

    ClipDescriptor& setSupportsTiles(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsTiles>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ClipInstance
class ClipInstance : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    const char* supportedComponents(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportedComponents>(index, error_if_missing);
    }

    bool temporalClipAccess(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropTemporalClipAccess>(0, error_if_missing);
    }

    const char* colourspace(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropColourspace>(0, error_if_missing);
    }

    const char* preferredColourspaces(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropPreferredColourspaces>(index, error_if_missing);
    }

    bool optional(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropOptional>(0, error_if_missing);
    }

    const char* fieldExtraction(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropFieldExtraction>(0, error_if_missing);
    }

    bool isMask(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropIsMask>(0, error_if_missing);
    }

    bool supportsTiles(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsTiles>(0, error_if_missing);
    }

    const char* pixelDepth(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropPixelDepth>(0, error_if_missing);
    }

    const char* components(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropComponents>(0, error_if_missing);
    }

    const char* unmappedPixelDepth(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropUnmappedPixelDepth>(0, error_if_missing);
    }

    const char* unmappedComponents(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropUnmappedComponents>(0, error_if_missing);
    }

    const char* preMultiplication(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropPreMultiplication>(0, error_if_missing);
    }

    double pixelAspectRatio(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImagePropPixelAspectRatio>(0, error_if_missing);
    }

    double frameRate(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropFrameRate>(0, error_if_missing);
    }

    std::array<double, 2> frameRange() const {
        return props_.getAll<PropId::OfxImageEffectPropFrameRange>();
    }

    const char* fieldOrder(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropFieldOrder>(0, error_if_missing);
    }

    bool connected(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropConnected>(0, error_if_missing);
    }

    std::array<double, 2> unmappedFrameRange() const {
        return props_.getAll<PropId::OfxImageEffectPropUnmappedFrameRange>();
    }

    double unmappedFrameRate(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropUnmappedFrameRate>(0, error_if_missing);
    }

    bool continuousSamples(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropContinuousSamples>(0, error_if_missing);
    }

};

// Property set accessor for: CustomParamInterpFunc_InArgs
class CustomParamInterpFunc_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    std::array<const char*, 2> customValue() const {
        return props_.getAll<PropId::OfxParamPropCustomValue>();
    }

    std::array<double, 2> interpolationTime() const {
        return props_.getAll<PropId::OfxParamPropInterpolationTime>();
    }

    double interpolationAmount(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInterpolationAmount>(0, error_if_missing);
    }

};

// Property set accessor for: CustomParamInterpFunc_OutArgs
class CustomParamInterpFunc_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    CustomParamInterpFunc_OutArgs& setCustomValue(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropCustomValue>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    CustomParamInterpFunc_OutArgs& setCustomValue(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropCustomValue>(values, error_if_missing);
        return *this;
    }

    CustomParamInterpFunc_OutArgs& setInterpolationTime(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInterpolationTime>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    CustomParamInterpFunc_OutArgs& setInterpolationTime(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInterpolationTime>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: EffectDescriptor
class EffectDescriptor : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    EffectDescriptor& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setVersion(int value, int index = 0, bool error_if_missing = false) {
        props_.set<PropId::OfxPropVersion>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    EffectDescriptor& setVersion(const Container& values, bool error_if_missing = false) {
        props_.setAll<PropId::OfxPropVersion>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    EffectDescriptor& setVersion(std::initializer_list<int> values, bool error_if_missing = false) {
        props_.setAll<PropId::OfxPropVersion>(values, error_if_missing);
        return *this;
    }

    EffectDescriptor& setVersionLabel(const char* value, bool error_if_missing = false) {
        props_.set<PropId::OfxPropVersionLabel>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setPluginDescription(const char* value, bool error_if_missing = false) {
        props_.set<PropId::OfxPropPluginDescription>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setSupportedContexts(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportedContexts>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    EffectDescriptor& setSupportedContexts(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedContexts>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    EffectDescriptor& setSupportedContexts(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedContexts>(values, error_if_missing);
        return *this;
    }

    EffectDescriptor& setImageEffectPluginPropGrouping(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPluginPropGrouping>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setImageEffectPluginPropSingleInstance(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPluginPropSingleInstance>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setImageEffectPluginRenderThreadSafety(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPluginRenderThreadSafety>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setImageEffectPluginPropHostFrameThreading(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPluginPropHostFrameThreading>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setImageEffectPluginPropOverlayInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPluginPropOverlayInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setOpenCLSupported(const char* value, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectPropOpenCLSupported>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setSupportsMultiResolution(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsMultiResolution>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setSupportsTiles(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsTiles>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setTemporalClipAccess(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropTemporalClipAccess>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setSupportedPixelDepths(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportedPixelDepths>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    EffectDescriptor& setSupportedPixelDepths(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedPixelDepths>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    EffectDescriptor& setSupportedPixelDepths(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedPixelDepths>(values, error_if_missing);
        return *this;
    }

    EffectDescriptor& setImageEffectPluginPropFieldRenderTwiceAlways(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPluginPropFieldRenderTwiceAlways>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setMultipleClipDepths(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMultipleClipDepths>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setSupportsMultipleClipPARs(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsMultipleClipPARs>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setClipPreferencesSlaveParam(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropClipPreferencesSlaveParam>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    EffectDescriptor& setClipPreferencesSlaveParam(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropClipPreferencesSlaveParam>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    EffectDescriptor& setClipPreferencesSlaveParam(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropClipPreferencesSlaveParam>(values, error_if_missing);
        return *this;
    }

    EffectDescriptor& setOpenGLRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    const char* filePath(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPluginPropFilePath>(0, error_if_missing);
    }

    EffectDescriptor& setPixelDepth(const char* value, int index = 0, bool error_if_missing = false) {
        props_.set<PropId::OfxOpenGLPropPixelDepth>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    EffectDescriptor& setPixelDepth(const Container& values, bool error_if_missing = false) {
        props_.setAll<PropId::OfxOpenGLPropPixelDepth>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    EffectDescriptor& setPixelDepth(std::initializer_list<const char*> values, bool error_if_missing = false) {
        props_.setAll<PropId::OfxOpenGLPropPixelDepth>(values, error_if_missing);
        return *this;
    }

    EffectDescriptor& setImageEffectPluginPropOverlayInteractV2(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPluginPropOverlayInteractV2>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setColourManagementAvailableConfigs(const char* value, int index = 0, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectPropColourManagementAvailableConfigs>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    EffectDescriptor& setColourManagementAvailableConfigs(const Container& values, bool error_if_missing = false) {
        props_.setAll<PropId::OfxImageEffectPropColourManagementAvailableConfigs>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    EffectDescriptor& setColourManagementAvailableConfigs(std::initializer_list<const char*> values, bool error_if_missing = false) {
        props_.setAll<PropId::OfxImageEffectPropColourManagementAvailableConfigs>(values, error_if_missing);
        return *this;
    }

    EffectDescriptor& setColourManagementStyle(const char* value, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectPropColourManagementStyle>(value, 0, error_if_missing);
        return *this;
    }

    EffectDescriptor& setNoSpatialAwareness(const char* value, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectPropNoSpatialAwareness>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: EffectInstance
class EffectInstance : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* context(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropContext>(0, error_if_missing);
    }

    void* instanceData(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropInstanceData>(0, error_if_missing);
    }

    std::array<double, 2> projectSize() const {
        return props_.getAll<PropId::OfxImageEffectPropProjectSize>();
    }

    std::array<double, 2> projectOffset() const {
        return props_.getAll<PropId::OfxImageEffectPropProjectOffset>();
    }

    std::array<double, 2> projectExtent() const {
        return props_.getAll<PropId::OfxImageEffectPropProjectExtent>();
    }

    double pixelAspectRatio(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropPixelAspectRatio>(0, error_if_missing);
    }

    double imageEffectInstancePropEffectDuration(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectInstancePropEffectDuration>(0, error_if_missing);
    }

    bool imageEffectInstancePropSequentialRender(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectInstancePropSequentialRender>(0, error_if_missing);
    }

    bool supportsTiles(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsTiles>(0, error_if_missing);
    }

    const char* openGLRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLRenderSupported>(0, error_if_missing);
    }

    double frameRate(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropFrameRate>(0, error_if_missing);
    }

    bool isInteractive(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropIsInteractive>(0, error_if_missing);
    }

    const char* oCIOConfig(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOCIOConfig>(0, error_if_missing);
    }

    const char* oCIODisplay(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOCIODisplay>(0, error_if_missing);
    }

    const char* oCIOView(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOCIOView>(0, error_if_missing);
    }

    const char* colourManagementConfig(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropColourManagementConfig>(0, error_if_missing);
    }

    const char* colourManagementStyle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropColourManagementStyle>(0, error_if_missing);
    }

    const char* displayColourspace(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropDisplayColourspace>(0, error_if_missing);
    }

    void* pluginHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropPluginHandle>(0, error_if_missing);
    }

};

// Property set accessor for: Image
class Image : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* pixelDepth(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropPixelDepth>(0, error_if_missing);
    }

    const char* components(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropComponents>(0, error_if_missing);
    }

    const char* preMultiplication(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropPreMultiplication>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

    double pixelAspectRatio(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImagePropPixelAspectRatio>(0, error_if_missing);
    }

    void* data(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImagePropData>(0, error_if_missing);
    }

    std::array<int, 4> bounds() const {
        return props_.getAll<PropId::OfxImagePropBounds>();
    }

    std::array<int, 4> regionOfDefinition() const {
        return props_.getAll<PropId::OfxImagePropRegionOfDefinition>();
    }

    int rowBytes(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImagePropRowBytes>(0, error_if_missing);
    }

    const char* field(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImagePropField>(0, error_if_missing);
    }

    const char* uniqueIdentifier(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImagePropUniqueIdentifier>(0, error_if_missing);
    }

};

// Property set accessor for: ImageEffectActionBeginSequenceRender_InArgs
class ImageEffectActionBeginSequenceRender_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    std::array<double, 2> frameRange() const {
        return props_.getAll<PropId::OfxImageEffectPropFrameRange>();
    }

    double frameStep(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropFrameStep>(0, error_if_missing);
    }

    bool isInteractive(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropIsInteractive>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

    bool sequentialRenderStatus(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSequentialRenderStatus>(0, error_if_missing);
    }

    bool interactiveRenderStatus(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropInteractiveRenderStatus>(0, error_if_missing);
    }

    bool cudaEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaEnabled>(0, error_if_missing);
    }

    const char* cudaRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaRenderSupported>(0, error_if_missing);
    }

    void* cudaStream(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaStream>(0, error_if_missing);
    }

    const char* cudaStreamSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaStreamSupported>(0, error_if_missing);
    }

    void* metalCommandQueue(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMetalCommandQueue>(0, error_if_missing);
    }

    bool metalEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMetalEnabled>(0, error_if_missing);
    }

    const char* metalRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMetalRenderSupported>(0, error_if_missing);
    }

    void* openCLCommandQueue(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLCommandQueue>(0, error_if_missing);
    }

    bool openCLEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLEnabled>(0, error_if_missing);
    }

    void* openCLImage(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLImage>(0, error_if_missing);
    }

    const char* openCLRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLRenderSupported>(0, error_if_missing);
    }

    const char* openCLSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLSupported>(0, error_if_missing);
    }

    bool openGLEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLEnabled>(0, error_if_missing);
    }

    int openGLTextureIndex(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLTextureIndex>(0, error_if_missing);
    }

    int openGLTextureTarget(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLTextureTarget>(0, error_if_missing);
    }

    const char* noSpatialAwareness(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropNoSpatialAwareness>(0, error_if_missing);
    }

};

// Property set accessor for: ImageEffectActionDescribeInContext_InArgs
class ImageEffectActionDescribeInContext_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* context(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropContext>(0, error_if_missing);
    }

};

// Property set accessor for: ImageEffectActionEndSequenceRender_InArgs
class ImageEffectActionEndSequenceRender_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    std::array<double, 2> frameRange() const {
        return props_.getAll<PropId::OfxImageEffectPropFrameRange>();
    }

    double frameStep(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropFrameStep>(0, error_if_missing);
    }

    bool isInteractive(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropIsInteractive>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

    bool sequentialRenderStatus(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSequentialRenderStatus>(0, error_if_missing);
    }

    bool interactiveRenderStatus(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropInteractiveRenderStatus>(0, error_if_missing);
    }

    bool cudaEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaEnabled>(0, error_if_missing);
    }

    const char* cudaRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaRenderSupported>(0, error_if_missing);
    }

    void* cudaStream(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaStream>(0, error_if_missing);
    }

    const char* cudaStreamSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaStreamSupported>(0, error_if_missing);
    }

    void* metalCommandQueue(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMetalCommandQueue>(0, error_if_missing);
    }

    bool metalEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMetalEnabled>(0, error_if_missing);
    }

    const char* metalRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMetalRenderSupported>(0, error_if_missing);
    }

    void* openCLCommandQueue(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLCommandQueue>(0, error_if_missing);
    }

    bool openCLEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLEnabled>(0, error_if_missing);
    }

    void* openCLImage(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLImage>(0, error_if_missing);
    }

    const char* openCLRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLRenderSupported>(0, error_if_missing);
    }

    const char* openCLSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLSupported>(0, error_if_missing);
    }

    bool openGLEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLEnabled>(0, error_if_missing);
    }

    int openGLTextureIndex(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLTextureIndex>(0, error_if_missing);
    }

    int openGLTextureTarget(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLTextureTarget>(0, error_if_missing);
    }

};

// Property set accessor for: ImageEffectActionGetClipPreferences_OutArgs
class ImageEffectActionGetClipPreferences_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionGetClipPreferences_OutArgs& setFrameRate(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropFrameRate>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionGetClipPreferences_OutArgs& setFieldOrder(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropFieldOrder>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionGetClipPreferences_OutArgs& setPreMultiplication(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropPreMultiplication>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionGetClipPreferences_OutArgs& setContinuousSamples(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropContinuousSamples>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionGetClipPreferences_OutArgs& setImageEffectFrameVarying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectFrameVarying>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionGetFramesNeeded_InArgs
class ImageEffectActionGetFramesNeeded_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

};

// Property set accessor for: ImageEffectActionGetFramesNeeded_OutArgs
class ImageEffectActionGetFramesNeeded_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionGetFramesNeeded_OutArgs& setFrameRange(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionGetFramesNeeded_OutArgs& setFrameRange(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionGetOutputColourspace_InArgs
class ImageEffectActionGetOutputColourspace_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* preferredColourspaces(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropPreferredColourspaces>(index, error_if_missing);
    }

};

// Property set accessor for: ImageEffectActionGetOutputColourspace_OutArgs
class ImageEffectActionGetOutputColourspace_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionGetOutputColourspace_OutArgs& setColourspace(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropColourspace>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionGetRegionOfDefinition_InArgs
class ImageEffectActionGetRegionOfDefinition_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

};

// Property set accessor for: ImageEffectActionGetRegionOfDefinition_OutArgs
class ImageEffectActionGetRegionOfDefinition_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionGetRegionOfDefinition_OutArgs& setRegionOfDefinition(const std::array<double, 4>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRegionOfDefinition>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionGetRegionOfDefinition_OutArgs& setRegionOfDefinition(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRegionOfDefinition>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionGetRegionsOfInterest_InArgs
class ImageEffectActionGetRegionsOfInterest_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

    std::array<double, 4> regionOfInterest() const {
        return props_.getAll<PropId::OfxImageEffectPropRegionOfInterest>();
    }

};

// Property set accessor for: ImageEffectActionGetTimeDomain_OutArgs
class ImageEffectActionGetTimeDomain_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionGetTimeDomain_OutArgs& setFrameRange(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionGetTimeDomain_OutArgs& setFrameRange(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionIsIdentity_InArgs
class ImageEffectActionIsIdentity_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    const char* fieldToRender(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropFieldToRender>(0, error_if_missing);
    }

    std::array<int, 4> renderWindow() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderWindow>();
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

};

// Property set accessor for: ImageEffectActionRender_InArgs
class ImageEffectActionRender_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    bool sequentialRenderStatus(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSequentialRenderStatus>(0, error_if_missing);
    }

    bool interactiveRenderStatus(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropInteractiveRenderStatus>(0, error_if_missing);
    }

    bool renderQualityDraft(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropRenderQualityDraft>(0, error_if_missing);
    }

    bool cudaEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaEnabled>(0, error_if_missing);
    }

    const char* cudaRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaRenderSupported>(0, error_if_missing);
    }

    void* cudaStream(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaStream>(0, error_if_missing);
    }

    const char* cudaStreamSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropCudaStreamSupported>(0, error_if_missing);
    }

    void* metalCommandQueue(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMetalCommandQueue>(0, error_if_missing);
    }

    bool metalEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMetalEnabled>(0, error_if_missing);
    }

    const char* metalRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMetalRenderSupported>(0, error_if_missing);
    }

    void* openCLCommandQueue(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLCommandQueue>(0, error_if_missing);
    }

    bool openCLEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLEnabled>(0, error_if_missing);
    }

    void* openCLImage(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLImage>(0, error_if_missing);
    }

    const char* openCLRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLRenderSupported>(0, error_if_missing);
    }

    const char* openCLSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLSupported>(0, error_if_missing);
    }

    bool openGLEnabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLEnabled>(0, error_if_missing);
    }

    int openGLTextureIndex(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLTextureIndex>(0, error_if_missing);
    }

    int openGLTextureTarget(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLTextureTarget>(0, error_if_missing);
    }

    const char* noSpatialAwareness(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropNoSpatialAwareness>(0, error_if_missing);
    }

};

// Property set accessor for: ImageEffectHost
class ImageEffectHost : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    int aPIVersion(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropAPIVersion>(index, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    int version(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropVersion>(index, error_if_missing);
    }

    const char* versionLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropVersionLabel>(0, error_if_missing);
    }

    bool imageEffectHostPropIsBackground(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectHostPropIsBackground>(0, error_if_missing);
    }

    bool supportsOverlays(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsOverlays>(0, error_if_missing);
    }

    bool supportsMultiResolution(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsMultiResolution>(0, error_if_missing);
    }

    bool supportsTiles(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsTiles>(0, error_if_missing);
    }

    bool temporalClipAccess(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropTemporalClipAccess>(0, error_if_missing);
    }

    const char* supportedComponents(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportedComponents>(index, error_if_missing);
    }

    const char* supportedContexts(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportedContexts>(index, error_if_missing);
    }

    bool multipleClipDepths(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMultipleClipDepths>(0, error_if_missing);
    }

    const char* openCLSupported(bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLSupported>(0, error_if_missing);
    }

    bool supportsMultipleClipPARs(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsMultipleClipPARs>(0, error_if_missing);
    }

    bool setableFrameRate(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSetableFrameRate>(0, error_if_missing);
    }

    bool setableFielding(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSetableFielding>(0, error_if_missing);
    }

    bool paramHostPropSupportsCustomInteract(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamHostPropSupportsCustomInteract>(0, error_if_missing);
    }

    bool paramHostPropSupportsStringAnimation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamHostPropSupportsStringAnimation>(0, error_if_missing);
    }

    bool paramHostPropSupportsChoiceAnimation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamHostPropSupportsChoiceAnimation>(0, error_if_missing);
    }

    bool paramHostPropSupportsBooleanAnimation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamHostPropSupportsBooleanAnimation>(0, error_if_missing);
    }

    bool paramHostPropSupportsCustomAnimation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamHostPropSupportsCustomAnimation>(0, error_if_missing);
    }

    bool paramHostPropSupportsStrChoice(bool error_if_missing = false) const {
        return props_.get<PropId::OfxParamHostPropSupportsStrChoice>(0, error_if_missing);
    }

    bool paramHostPropSupportsStrChoiceAnimation(bool error_if_missing = false) const {
        return props_.get<PropId::OfxParamHostPropSupportsStrChoiceAnimation>(0, error_if_missing);
    }

    int paramHostPropMaxParameters(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamHostPropMaxParameters>(0, error_if_missing);
    }

    int paramHostPropMaxPages(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamHostPropMaxPages>(0, error_if_missing);
    }

    std::array<int, 2> paramHostPropPageRowColumnCount() const {
        return props_.getAll<PropId::OfxParamHostPropPageRowColumnCount>();
    }

    void* hostOSHandle(bool error_if_missing = false) const {
        return props_.get<PropId::OfxPropHostOSHandle>(0, error_if_missing);
    }

    bool paramHostPropSupportsParametricAnimation(bool error_if_missing = false) const {
        return props_.get<PropId::OfxParamHostPropSupportsParametricAnimation>(0, error_if_missing);
    }

    bool imageEffectInstancePropSequentialRender(bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectInstancePropSequentialRender>(0, error_if_missing);
    }

    const char* openGLRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLRenderSupported>(0, error_if_missing);
    }

    bool renderQualityDraft(bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectPropRenderQualityDraft>(0, error_if_missing);
    }

    const char* imageEffectHostPropNativeOrigin(bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectHostPropNativeOrigin>(0, error_if_missing);
    }

    const char* colourManagementAvailableConfigs(int index = 0, bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectPropColourManagementAvailableConfigs>(index, error_if_missing);
    }

    const char* colourManagementStyle(bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectPropColourManagementStyle>(0, error_if_missing);
    }

};

// Property set accessor for: InteractActionDraw_InArgs
class InteractActionDraw_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    void* interactPropDrawContext(bool error_if_missing = true) const {
        return props_.get<PropId::OfxInteractPropDrawContext>(0, error_if_missing);
    }

    std::array<double, 2> interactPropPixelScale() const {
        return props_.getAll<PropId::OfxInteractPropPixelScale>();
    }

    std::array<double, 3> interactPropBackgroundColour() const {
        return props_.getAll<PropId::OfxInteractPropBackgroundColour>();
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

};

// Property set accessor for: InteractActionGainFocus_InArgs
class InteractActionGainFocus_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    std::array<double, 2> interactPropPixelScale() const {
        return props_.getAll<PropId::OfxInteractPropPixelScale>();
    }

    std::array<double, 3> interactPropBackgroundColour() const {
        return props_.getAll<PropId::OfxInteractPropBackgroundColour>();
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

};

// Property set accessor for: InteractActionKeyDown_InArgs
class InteractActionKeyDown_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    int keySym(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropKeySym>(0, error_if_missing);
    }

    const char* keyString(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropKeyString>(0, error_if_missing);
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

};

// Property set accessor for: InteractActionKeyRepeat_InArgs
class InteractActionKeyRepeat_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    int keySym(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropKeySym>(0, error_if_missing);
    }

    const char* keyString(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropKeyString>(0, error_if_missing);
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

};

// Property set accessor for: InteractActionKeyUp_InArgs
class InteractActionKeyUp_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    int keySym(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropKeySym>(0, error_if_missing);
    }

    const char* keyString(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropKeyString>(0, error_if_missing);
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

};

// Property set accessor for: InteractActionLoseFocus_InArgs
class InteractActionLoseFocus_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    std::array<double, 2> interactPropPixelScale() const {
        return props_.getAll<PropId::OfxInteractPropPixelScale>();
    }

    std::array<double, 3> interactPropBackgroundColour() const {
        return props_.getAll<PropId::OfxInteractPropBackgroundColour>();
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

};

// Property set accessor for: InteractActionPenDown_InArgs
class InteractActionPenDown_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    std::array<double, 2> interactPropPixelScale() const {
        return props_.getAll<PropId::OfxInteractPropPixelScale>();
    }

    std::array<double, 3> interactPropBackgroundColour() const {
        return props_.getAll<PropId::OfxInteractPropBackgroundColour>();
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

    std::array<double, 2> interactPropPenPosition() const {
        return props_.getAll<PropId::OfxInteractPropPenPosition>();
    }

    std::array<int, 2> interactPropPenViewportPosition() const {
        return props_.getAll<PropId::OfxInteractPropPenViewportPosition>();
    }

    double interactPropPenPressure(bool error_if_missing = true) const {
        return props_.get<PropId::OfxInteractPropPenPressure>(0, error_if_missing);
    }

};

// Property set accessor for: InteractActionPenMotion_InArgs
class InteractActionPenMotion_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    std::array<double, 2> interactPropPixelScale() const {
        return props_.getAll<PropId::OfxInteractPropPixelScale>();
    }

    std::array<double, 3> interactPropBackgroundColour() const {
        return props_.getAll<PropId::OfxInteractPropBackgroundColour>();
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

    std::array<double, 2> interactPropPenPosition() const {
        return props_.getAll<PropId::OfxInteractPropPenPosition>();
    }

    std::array<int, 2> interactPropPenViewportPosition() const {
        return props_.getAll<PropId::OfxInteractPropPenViewportPosition>();
    }

    double interactPropPenPressure(bool error_if_missing = true) const {
        return props_.get<PropId::OfxInteractPropPenPressure>(0, error_if_missing);
    }

};

// Property set accessor for: InteractActionPenUp_InArgs
class InteractActionPenUp_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    std::array<double, 2> interactPropPixelScale() const {
        return props_.getAll<PropId::OfxInteractPropPixelScale>();
    }

    std::array<double, 3> interactPropBackgroundColour() const {
        return props_.getAll<PropId::OfxInteractPropBackgroundColour>();
    }

    double time(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropTime>(0, error_if_missing);
    }

    std::array<double, 2> renderScale() const {
        return props_.getAll<PropId::OfxImageEffectPropRenderScale>();
    }

    std::array<double, 2> interactPropPenPosition() const {
        return props_.getAll<PropId::OfxInteractPropPenPosition>();
    }

    std::array<int, 2> interactPropPenViewportPosition() const {
        return props_.getAll<PropId::OfxInteractPropPenViewportPosition>();
    }

    double interactPropPenPressure(bool error_if_missing = true) const {
        return props_.get<PropId::OfxInteractPropPenPressure>(0, error_if_missing);
    }

};

// Property set accessor for: InteractDescriptor
class InteractDescriptor : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    bool interactPropHasAlpha(bool error_if_missing = true) const {
        return props_.get<PropId::OfxInteractPropHasAlpha>(0, error_if_missing);
    }

    int interactPropBitDepth(bool error_if_missing = true) const {
        return props_.get<PropId::OfxInteractPropBitDepth>(0, error_if_missing);
    }

};

// Property set accessor for: InteractInstance
class InteractInstance : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* effectInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropEffectInstance>(0, error_if_missing);
    }

    void* instanceData(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropInstanceData>(0, error_if_missing);
    }

    std::array<double, 2> interactPropPixelScale() const {
        return props_.getAll<PropId::OfxInteractPropPixelScale>();
    }

    std::array<double, 3> interactPropBackgroundColour() const {
        return props_.getAll<PropId::OfxInteractPropBackgroundColour>();
    }

    bool interactPropHasAlpha(bool error_if_missing = true) const {
        return props_.get<PropId::OfxInteractPropHasAlpha>(0, error_if_missing);
    }

    int interactPropBitDepth(bool error_if_missing = true) const {
        return props_.get<PropId::OfxInteractPropBitDepth>(0, error_if_missing);
    }

    const char* interactPropSlaveToParam(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxInteractPropSlaveToParam>(index, error_if_missing);
    }

    std::array<double, 3> interactPropSuggestedColour() const {
        return props_.getAll<PropId::OfxInteractPropSuggestedColour>();
    }

};

// Property set accessor for: ParamDouble1D
class ParamDouble1D : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamDouble1D& setShowTimeMarker(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropShowTimeMarker>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setDoubleType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDoubleType>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamDouble1D& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamDouble1D& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamDouble1D& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamDouble1D& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamDouble1D& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamDouble1D& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamDouble1D& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamDouble1D& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamDouble1D& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamDouble1D& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamDouble1D& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    ParamDouble1D& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    ParamDouble1D& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamDouble1D& setMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamDouble1D& setMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamDouble1D& setMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamDouble1D& setMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamDouble1D& setMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamDouble1D& setMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamDouble1D& setDisplayMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamDouble1D& setDisplayMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamDouble1D& setDisplayMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamDouble1D& setDisplayMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamDouble1D& setDisplayMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamDouble1D& setDisplayMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

    ParamDouble1D& setIncrement(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIncrement>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setDigits(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDigits>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParameterSet
class ParameterSet : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParameterSet& setParamSetNeedsSyncing(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropParamSetNeedsSyncing>(value, 0, error_if_missing);
        return *this;
    }

    ParameterSet& setParamPageOrder(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxPluginPropParamPageOrder>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParameterSet& setParamPageOrder(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPluginPropParamPageOrder>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ParameterSet& setParamPageOrder(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPluginPropParamPageOrder>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsByte
class ParamsByte : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsByte& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsByte& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamsByte& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsByte& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamsByte& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsByte& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamsByte& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsByte& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamsByte& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamsByte& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsByte& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsByte& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    ParamsByte& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    ParamsByte& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsByte& setMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsByte& setMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsByte& setMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsByte& setMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsByte& setMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsByte& setMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsByte& setDisplayMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsByte& setDisplayMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsByte& setDisplayMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsByte& setDisplayMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsByte& setDisplayMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsByte& setDisplayMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsChoice
class ParamsChoice : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsChoice& setChoiceOption(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropChoiceOption>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsChoice& setChoiceOption(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropChoiceOption>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ParamsChoice& setChoiceOption(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropChoiceOption>(values, error_if_missing);
        return *this;
    }

    ParamsChoice& setChoiceOrder(int value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropChoiceOrder>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsChoice& setChoiceOrder(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropChoiceOrder>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ParamsChoice& setChoiceOrder(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropChoiceOrder>(values, error_if_missing);
        return *this;
    }

    ParamsChoice& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsChoice& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamsChoice& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsChoice& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamsChoice& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsChoice& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamsChoice& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsChoice& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamsChoice& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamsChoice& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsChoice& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsChoice& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    ParamsChoice& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    ParamsChoice& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsCustom
class ParamsCustom : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsCustom& setCustomCallbackV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCustomCallbackV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsCustom& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamsCustom& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsCustom& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamsCustom& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsCustom& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamsCustom& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsCustom& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamsCustom& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamsCustom& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsCustom& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsCustom& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    ParamsCustom& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    ParamsCustom& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsDouble2D3D
class ParamsDouble2D3D : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsDouble2D3D& setDoubleType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDoubleType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsDouble2D3D& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsDouble2D3D& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsDouble2D3D& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsDouble2D3D& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamsDouble2D3D& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsDouble2D3D& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsDouble2D3D& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    ParamsDouble2D3D& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsDouble2D3D& setMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsDouble2D3D& setMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsDouble2D3D& setMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsDouble2D3D& setMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsDouble2D3D& setMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsDouble2D3D& setMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsDouble2D3D& setDisplayMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsDouble2D3D& setDisplayMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsDouble2D3D& setDisplayMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsDouble2D3D& setDisplayMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsDouble2D3D& setDisplayMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsDouble2D3D& setDisplayMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setIncrement(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIncrement>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setDigits(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDigits>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsGroup
class ParamsGroup : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsGroup& setGroupOpen(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropGroupOpen>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsGroup& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsGroup& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsInt2D3D
class ParamsInt2D3D : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsInt2D3D& setDimensionLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDimensionLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsInt2D3D& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsInt2D3D& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsInt2D3D& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsInt2D3D& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamsInt2D3D& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsInt2D3D& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsInt2D3D& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    ParamsInt2D3D& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsInt2D3D& setMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsInt2D3D& setMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsInt2D3D& setMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsInt2D3D& setMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsInt2D3D& setMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsInt2D3D& setMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsInt2D3D& setDisplayMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsInt2D3D& setDisplayMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsInt2D3D& setDisplayMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsInt2D3D& setDisplayMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsInt2D3D& setDisplayMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsInt2D3D& setDisplayMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsNormalizedSpatial
class ParamsNormalizedSpatial : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsNormalizedSpatial& setDefaultCoordinateSystem(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefaultCoordinateSystem>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsNormalizedSpatial& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsNormalizedSpatial& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsNormalizedSpatial& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsNormalizedSpatial& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamsNormalizedSpatial& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsNormalizedSpatial& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsNormalizedSpatial& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    ParamsNormalizedSpatial& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsNormalizedSpatial& setMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsNormalizedSpatial& setMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsNormalizedSpatial& setMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsNormalizedSpatial& setMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsNormalizedSpatial& setMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsNormalizedSpatial& setMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsNormalizedSpatial& setDisplayMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsNormalizedSpatial& setDisplayMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsNormalizedSpatial& setDisplayMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsNormalizedSpatial& setDisplayMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsNormalizedSpatial& setDisplayMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsNormalizedSpatial& setDisplayMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setIncrement(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIncrement>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setDigits(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDigits>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsPage
class ParamsPage : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsPage& setPageChild(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPageChild>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsPage& setPageChild(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropPageChild>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ParamsPage& setPageChild(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropPageChild>(values, error_if_missing);
        return *this;
    }

    ParamsPage& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsPage& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsPage& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsParametric
class ParamsParametric : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsParametric& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setParametricDimension(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParametricDimension>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setParametricUIColour(double value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParametricUIColour>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsParametric& setParametricUIColour(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropParametricUIColour>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ParamsParametric& setParametricUIColour(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropParametricUIColour>(values, error_if_missing);
        return *this;
    }

    ParamsParametric& setParametricInteractBackground(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParametricInteractBackground>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setParametricRange(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropParametricRange>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsParametric& setParametricRange(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropParametricRange>(values, error_if_missing);
        return *this;
    }

    ParamsParametric& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsParametric& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamsParametric& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsParametric& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamsParametric& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsParametric& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamsParametric& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsParametric& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamsParametric& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamsParametric& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamsParametric& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsParametric& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsParametric& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsStrChoice
class ParamsStrChoice : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsStrChoice& setChoiceOption(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropChoiceOption>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsStrChoice& setChoiceOption(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropChoiceOption>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ParamsStrChoice& setChoiceOption(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropChoiceOption>(values, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setChoiceEnum(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropChoiceEnum>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsStrChoice& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsStrChoice& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsStrChoice& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsStrChoice& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamsStrChoice& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsStrChoice& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsStrChoice& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    ParamsStrChoice& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamsString
class ParamsString : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ParamsString& setStringMode(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropStringMode>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setStringFilePathExists(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropStringFilePathExists>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setSecret(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropSecret>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setHint(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHint>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setScriptName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropScriptName>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setParent(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropParent>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setDataPtr(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDataPtr>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setIcon(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsString& setIcon(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropIcon>(values, error_if_missing);
        return *this;
    }

    ParamsString& setInteractV1(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractV1>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setInteractSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsString& setInteractSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractSize>(values, error_if_missing);
        return *this;
    }

    ParamsString& setInteractSizeAspect(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInteractSizeAspect>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setInteractMinimumSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsString& setInteractMinimumSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractMinimumSize>(values, error_if_missing);
        return *this;
    }

    ParamsString& setInteractPreferedSize(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ParamsString& setInteractPreferedSize(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInteractPreferedSize>(values, error_if_missing);
        return *this;
    }

    ParamsString& setHasHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropHasHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setUseHostOverlayHandle(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropUseHostOverlayHandle>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    ParamsString& setDefault(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDefault, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsString& setDefault(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsString& setDefault(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDefault, T>(values, error_if_missing);
        return *this;
    }

    ParamsString& setAnimates(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropAnimates>(value, 0, error_if_missing);
        return *this;
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    ParamsString& setPersistant(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPersistant>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setEvaluateOnChange(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropEvaluateOnChange>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setPluginMayWrite(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropPluginMayWrite>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setCacheInvalidation(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCacheInvalidation>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setCanUndo(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropCanUndo>(value, 0, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsString& setMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsString& setMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsString& setMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsString& setMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsString& setMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsString& setMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropMax, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsString& setDisplayMin(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMin, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsString& setDisplayMin(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsString& setDisplayMin(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMin, T>(values, error_if_missing);
        return *this;
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    ParamsString& setDisplayMax(T value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropDisplayMax, T>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename T, typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ParamsString& setDisplayMax(const Container& values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    template<typename T>
    ParamsString& setDisplayMax(std::initializer_list<T> values, bool error_if_missing = true) {
        props_.setAllTyped<PropId::OfxParamPropDisplayMax, T>(values, error_if_missing);
        return *this;
    }

};

} // namespace openfx
