// Copyright OpenFX and contributors to the OpenFX project.
// SPDX-License-Identifier: BSD-3-Clause
// NOTE: This file is auto-generated by gen-props.py. DO NOT EDIT.

#pragma once

#include <array>
#include <vector>
#include "ofxPropsAccess.h"
#include "ofxPropsMetadata.h"

namespace openfx {

// Type-safe property set accessor classes for HOSTS
//
// These wrapper classes provide convenient, type-safe access to property sets.
// - For plugins: getters for host-written properties, setters for plugin-written properties
// - For hosts: setters for host-written properties, getters for plugin-written properties
//
// Usage:
//   PropertyAccessor accessor(handle, propSuite);
//   EffectDescriptor desc(accessor);
//   desc.setLabel("My Effect");  // Type-safe setter
//   auto label = desc.label();    // Type-safe getter

// Base class for property set accessors
class PropertySetAccessor {
protected:
    PropertyAccessor& props_;
public:
    explicit PropertySetAccessor(PropertyAccessor& p) : props_(p) {}

    // Access to underlying PropertyAccessor for advanced use
    PropertyAccessor& props() { return props_; }
    const PropertyAccessor& props() const { return props_; }
};

// Property set accessor for: ActionBeginInstanceChanged_InArgs
class ActionBeginInstanceChanged_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ActionBeginInstanceChanged_InArgs& setChangeReason(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropChangeReason>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ActionEndInstanceChanged_InArgs
class ActionEndInstanceChanged_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ActionEndInstanceChanged_InArgs& setChangeReason(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropChangeReason>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ActionInstanceChanged_InArgs
class ActionInstanceChanged_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ActionInstanceChanged_InArgs& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ActionInstanceChanged_InArgs& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ActionInstanceChanged_InArgs& setChangeReason(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropChangeReason>(value, 0, error_if_missing);
        return *this;
    }

    ActionInstanceChanged_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    ActionInstanceChanged_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ActionInstanceChanged_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ClipDescriptor
class ClipDescriptor : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    const char* supportedComponents(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportedComponents>(index, error_if_missing);
    }

    bool temporalClipAccess(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropTemporalClipAccess>(0, error_if_missing);
    }

    bool optional(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropOptional>(0, error_if_missing);
    }

    const char* fieldExtraction(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropFieldExtraction>(0, error_if_missing);
    }

    bool isMask(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropIsMask>(0, error_if_missing);
    }

    bool supportsTiles(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsTiles>(0, error_if_missing);
    }

};

// Property set accessor for: ClipInstance
class ClipInstance : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ClipInstance& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setShortLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropShortLabel>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setLongLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLongLabel>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setSupportedComponents(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportedComponents>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ClipInstance& setSupportedComponents(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedComponents>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ClipInstance& setSupportedComponents(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedComponents>(values, error_if_missing);
        return *this;
    }

    ClipInstance& setTemporalClipAccess(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropTemporalClipAccess>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setColourspace(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropColourspace>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setPreferredColourspaces(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropPreferredColourspaces>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ClipInstance& setPreferredColourspaces(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageClipPropPreferredColourspaces>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ClipInstance& setPreferredColourspaces(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageClipPropPreferredColourspaces>(values, error_if_missing);
        return *this;
    }

    ClipInstance& setOptional(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropOptional>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setFieldExtraction(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropFieldExtraction>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setIsMask(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropIsMask>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setSupportsTiles(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsTiles>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setPixelDepth(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropPixelDepth>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setComponents(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropComponents>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setUnmappedPixelDepth(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropUnmappedPixelDepth>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setUnmappedComponents(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropUnmappedComponents>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setPreMultiplication(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropPreMultiplication>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setPixelAspectRatio(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImagePropPixelAspectRatio>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setFrameRate(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropFrameRate>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setFrameRange(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ClipInstance& setFrameRange(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

    ClipInstance& setFieldOrder(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropFieldOrder>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setConnected(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropConnected>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setUnmappedFrameRange(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropUnmappedFrameRange>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ClipInstance& setUnmappedFrameRange(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropUnmappedFrameRange>(values, error_if_missing);
        return *this;
    }

    ClipInstance& setUnmappedFrameRate(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropUnmappedFrameRate>(value, 0, error_if_missing);
        return *this;
    }

    ClipInstance& setContinuousSamples(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropContinuousSamples>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: CustomParamInterpFunc_InArgs
class CustomParamInterpFunc_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    CustomParamInterpFunc_InArgs& setCustomValue(const std::array<const char*, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropCustomValue>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    CustomParamInterpFunc_InArgs& setCustomValue(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropCustomValue>(values, error_if_missing);
        return *this;
    }

    CustomParamInterpFunc_InArgs& setInterpolationTime(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInterpolationTime>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    CustomParamInterpFunc_InArgs& setInterpolationTime(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamPropInterpolationTime>(values, error_if_missing);
        return *this;
    }

    CustomParamInterpFunc_InArgs& setInterpolationAmount(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropInterpolationAmount>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: CustomParamInterpFunc_OutArgs
class CustomParamInterpFunc_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    std::array<const char*, 2> customValue() const {
        return props_.getAll<PropId::OfxParamPropCustomValue>();
    }

    std::array<double, 2> interpolationTime() const {
        return props_.getAll<PropId::OfxParamPropInterpolationTime>();
    }

};

// Property set accessor for: EffectDescriptor
class EffectDescriptor : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    int version(int index = 0, bool error_if_missing = false) const {
        return props_.get<PropId::OfxPropVersion>(index, error_if_missing);
    }

    const char* versionLabel(bool error_if_missing = false) const {
        return props_.get<PropId::OfxPropVersionLabel>(0, error_if_missing);
    }

    const char* pluginDescription(bool error_if_missing = false) const {
        return props_.get<PropId::OfxPropPluginDescription>(0, error_if_missing);
    }

    const char* supportedContexts(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportedContexts>(index, error_if_missing);
    }

    const char* imageEffectPluginPropGrouping(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPluginPropGrouping>(0, error_if_missing);
    }

    bool imageEffectPluginPropSingleInstance(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPluginPropSingleInstance>(0, error_if_missing);
    }

    const char* imageEffectPluginRenderThreadSafety(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPluginRenderThreadSafety>(0, error_if_missing);
    }

    bool imageEffectPluginPropHostFrameThreading(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPluginPropHostFrameThreading>(0, error_if_missing);
    }

    void* imageEffectPluginPropOverlayInteractV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPluginPropOverlayInteractV1>(0, error_if_missing);
    }

    const char* openCLSupported(bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectPropOpenCLSupported>(0, error_if_missing);
    }

    bool supportsMultiResolution(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsMultiResolution>(0, error_if_missing);
    }

    bool supportsTiles(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsTiles>(0, error_if_missing);
    }

    bool temporalClipAccess(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropTemporalClipAccess>(0, error_if_missing);
    }

    const char* supportedPixelDepths(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportedPixelDepths>(index, error_if_missing);
    }

    bool imageEffectPluginPropFieldRenderTwiceAlways(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPluginPropFieldRenderTwiceAlways>(0, error_if_missing);
    }

    bool multipleClipDepths(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropMultipleClipDepths>(0, error_if_missing);
    }

    bool supportsMultipleClipPARs(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropSupportsMultipleClipPARs>(0, error_if_missing);
    }

    const char* clipPreferencesSlaveParam(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropClipPreferencesSlaveParam>(index, error_if_missing);
    }

    const char* openGLRenderSupported(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropOpenGLRenderSupported>(0, error_if_missing);
    }

    EffectDescriptor& setFilePath(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPluginPropFilePath>(value, 0, error_if_missing);
        return *this;
    }

    const char* pixelDepth(int index = 0, bool error_if_missing = false) const {
        return props_.get<PropId::OfxOpenGLPropPixelDepth>(index, error_if_missing);
    }

    void* imageEffectPluginPropOverlayInteractV2(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPluginPropOverlayInteractV2>(0, error_if_missing);
    }

    const char* colourManagementAvailableConfigs(int index = 0, bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectPropColourManagementAvailableConfigs>(index, error_if_missing);
    }

    const char* colourManagementStyle(bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectPropColourManagementStyle>(0, error_if_missing);
    }

    const char* noSpatialAwareness(bool error_if_missing = false) const {
        return props_.get<PropId::OfxImageEffectPropNoSpatialAwareness>(0, error_if_missing);
    }

};

// Property set accessor for: EffectInstance
class EffectInstance : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    EffectInstance& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setContext(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropContext>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setInstanceData(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropInstanceData>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setProjectSize(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropProjectSize>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    EffectInstance& setProjectSize(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropProjectSize>(values, error_if_missing);
        return *this;
    }

    EffectInstance& setProjectOffset(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropProjectOffset>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    EffectInstance& setProjectOffset(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropProjectOffset>(values, error_if_missing);
        return *this;
    }

    EffectInstance& setProjectExtent(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropProjectExtent>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    EffectInstance& setProjectExtent(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropProjectExtent>(values, error_if_missing);
        return *this;
    }

    EffectInstance& setPixelAspectRatio(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropPixelAspectRatio>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setImageEffectInstancePropEffectDuration(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectInstancePropEffectDuration>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setImageEffectInstancePropSequentialRender(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectInstancePropSequentialRender>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setSupportsTiles(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsTiles>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setOpenGLRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setFrameRate(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropFrameRate>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setIsInteractive(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropIsInteractive>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setOCIOConfig(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOCIOConfig>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setOCIODisplay(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOCIODisplay>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setOCIOView(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOCIOView>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setColourManagementConfig(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropColourManagementConfig>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setColourManagementStyle(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropColourManagementStyle>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setDisplayColourspace(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropDisplayColourspace>(value, 0, error_if_missing);
        return *this;
    }

    EffectInstance& setPluginHandle(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropPluginHandle>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: Image
class Image : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    Image& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    Image& setPixelDepth(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropPixelDepth>(value, 0, error_if_missing);
        return *this;
    }

    Image& setComponents(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropComponents>(value, 0, error_if_missing);
        return *this;
    }

    Image& setPreMultiplication(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropPreMultiplication>(value, 0, error_if_missing);
        return *this;
    }

    Image& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    Image& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    Image& setPixelAspectRatio(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImagePropPixelAspectRatio>(value, 0, error_if_missing);
        return *this;
    }

    Image& setData(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImagePropData>(value, 0, error_if_missing);
        return *this;
    }

    Image& setBounds(const std::array<int, 4>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImagePropBounds>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    Image& setBounds(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImagePropBounds>(values, error_if_missing);
        return *this;
    }

    Image& setRegionOfDefinition(const std::array<int, 4>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImagePropRegionOfDefinition>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    Image& setRegionOfDefinition(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImagePropRegionOfDefinition>(values, error_if_missing);
        return *this;
    }

    Image& setRowBytes(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxImagePropRowBytes>(value, 0, error_if_missing);
        return *this;
    }

    Image& setField(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImagePropField>(value, 0, error_if_missing);
        return *this;
    }

    Image& setUniqueIdentifier(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImagePropUniqueIdentifier>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionBeginSequenceRender_InArgs
class ImageEffectActionBeginSequenceRender_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionBeginSequenceRender_InArgs& setFrameRange(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionBeginSequenceRender_InArgs& setFrameRange(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setFrameStep(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropFrameStep>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setIsInteractive(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropIsInteractive>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionBeginSequenceRender_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setSequentialRenderStatus(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSequentialRenderStatus>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setInteractiveRenderStatus(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropInteractiveRenderStatus>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setCudaEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setCudaRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setCudaStream(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaStream>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setCudaStreamSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaStreamSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setMetalCommandQueue(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMetalCommandQueue>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setMetalEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMetalEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setMetalRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMetalRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setOpenCLCommandQueue(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLCommandQueue>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setOpenCLEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setOpenCLImage(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLImage>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setOpenCLRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setOpenCLSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setOpenGLEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setOpenGLTextureIndex(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLTextureIndex>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setOpenGLTextureTarget(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLTextureTarget>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionBeginSequenceRender_InArgs& setNoSpatialAwareness(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropNoSpatialAwareness>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionDescribeInContext_InArgs
class ImageEffectActionDescribeInContext_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionDescribeInContext_InArgs& setContext(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropContext>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionEndSequenceRender_InArgs
class ImageEffectActionEndSequenceRender_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionEndSequenceRender_InArgs& setFrameRange(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionEndSequenceRender_InArgs& setFrameRange(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropFrameRange>(values, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setFrameStep(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropFrameStep>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setIsInteractive(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropIsInteractive>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionEndSequenceRender_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setSequentialRenderStatus(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSequentialRenderStatus>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setInteractiveRenderStatus(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropInteractiveRenderStatus>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setCudaEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setCudaRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setCudaStream(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaStream>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setCudaStreamSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaStreamSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setMetalCommandQueue(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMetalCommandQueue>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setMetalEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMetalEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setMetalRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMetalRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setOpenCLCommandQueue(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLCommandQueue>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setOpenCLEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setOpenCLImage(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLImage>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setOpenCLRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setOpenCLSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setOpenGLEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setOpenGLTextureIndex(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLTextureIndex>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionEndSequenceRender_InArgs& setOpenGLTextureTarget(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLTextureTarget>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionGetClipPreferences_OutArgs
class ImageEffectActionGetClipPreferences_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    double frameRate(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropFrameRate>(0, error_if_missing);
    }

    const char* fieldOrder(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropFieldOrder>(0, error_if_missing);
    }

    const char* preMultiplication(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectPropPreMultiplication>(0, error_if_missing);
    }

    bool continuousSamples(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropContinuousSamples>(0, error_if_missing);
    }

    bool imageEffectFrameVarying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageEffectFrameVarying>(0, error_if_missing);
    }

};

// Property set accessor for: ImageEffectActionGetFramesNeeded_InArgs
class ImageEffectActionGetFramesNeeded_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionGetFramesNeeded_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionGetFramesNeeded_OutArgs
class ImageEffectActionGetFramesNeeded_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    std::array<double, 2> frameRange() const {
        return props_.getAll<PropId::OfxImageEffectPropFrameRange>();
    }

};

// Property set accessor for: ImageEffectActionGetOutputColourspace_InArgs
class ImageEffectActionGetOutputColourspace_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionGetOutputColourspace_InArgs& setPreferredColourspaces(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxImageClipPropPreferredColourspaces>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ImageEffectActionGetOutputColourspace_InArgs& setPreferredColourspaces(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageClipPropPreferredColourspaces>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ImageEffectActionGetOutputColourspace_InArgs& setPreferredColourspaces(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageClipPropPreferredColourspaces>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionGetOutputColourspace_OutArgs
class ImageEffectActionGetOutputColourspace_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* colourspace(bool error_if_missing = true) const {
        return props_.get<PropId::OfxImageClipPropColourspace>(0, error_if_missing);
    }

};

// Property set accessor for: ImageEffectActionGetRegionOfDefinition_InArgs
class ImageEffectActionGetRegionOfDefinition_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionGetRegionOfDefinition_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionGetRegionOfDefinition_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionGetRegionOfDefinition_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionGetRegionOfDefinition_OutArgs
class ImageEffectActionGetRegionOfDefinition_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    std::array<double, 4> regionOfDefinition() const {
        return props_.getAll<PropId::OfxImageEffectPropRegionOfDefinition>();
    }

};

// Property set accessor for: ImageEffectActionGetRegionsOfInterest_InArgs
class ImageEffectActionGetRegionsOfInterest_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionGetRegionsOfInterest_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionGetRegionsOfInterest_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionGetRegionsOfInterest_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    ImageEffectActionGetRegionsOfInterest_InArgs& setRegionOfInterest(const std::array<double, 4>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRegionOfInterest>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionGetRegionsOfInterest_InArgs& setRegionOfInterest(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRegionOfInterest>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionGetTimeDomain_OutArgs
class ImageEffectActionGetTimeDomain_OutArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    std::array<double, 2> frameRange() const {
        return props_.getAll<PropId::OfxImageEffectPropFrameRange>();
    }

};

// Property set accessor for: ImageEffectActionIsIdentity_InArgs
class ImageEffectActionIsIdentity_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionIsIdentity_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionIsIdentity_InArgs& setFieldToRender(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropFieldToRender>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionIsIdentity_InArgs& setRenderWindow(const std::array<int, 4>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderWindow>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionIsIdentity_InArgs& setRenderWindow(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderWindow>(values, error_if_missing);
        return *this;
    }

    ImageEffectActionIsIdentity_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectActionIsIdentity_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectActionRender_InArgs
class ImageEffectActionRender_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectActionRender_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setSequentialRenderStatus(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSequentialRenderStatus>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setInteractiveRenderStatus(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropInteractiveRenderStatus>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setRenderQualityDraft(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropRenderQualityDraft>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setCudaEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setCudaRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setCudaStream(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaStream>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setCudaStreamSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropCudaStreamSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setMetalCommandQueue(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMetalCommandQueue>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setMetalEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMetalEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setMetalRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMetalRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setOpenCLCommandQueue(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLCommandQueue>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setOpenCLEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setOpenCLImage(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLImage>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setOpenCLRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setOpenCLSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenCLSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setOpenGLEnabled(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLEnabled>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setOpenGLTextureIndex(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLTextureIndex>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setOpenGLTextureTarget(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLTextureTarget>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectActionRender_InArgs& setNoSpatialAwareness(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropNoSpatialAwareness>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ImageEffectHost
class ImageEffectHost : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    ImageEffectHost& setAPIVersion(int value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxPropAPIVersion>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ImageEffectHost& setAPIVersion(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropAPIVersion>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ImageEffectHost& setAPIVersion(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropAPIVersion>(values, error_if_missing);
        return *this;
    }

    ImageEffectHost& setType(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropType>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setName(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropName>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropLabel>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setVersion(int value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxPropVersion>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ImageEffectHost& setVersion(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropVersion>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ImageEffectHost& setVersion(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxPropVersion>(values, error_if_missing);
        return *this;
    }

    ImageEffectHost& setVersionLabel(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropVersionLabel>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setImageEffectHostPropIsBackground(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectHostPropIsBackground>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setSupportsOverlays(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsOverlays>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setSupportsMultiResolution(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsMultiResolution>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setSupportsTiles(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsTiles>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setTemporalClipAccess(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropTemporalClipAccess>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setSupportedComponents(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportedComponents>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ImageEffectHost& setSupportedComponents(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedComponents>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ImageEffectHost& setSupportedComponents(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedComponents>(values, error_if_missing);
        return *this;
    }

    ImageEffectHost& setSupportedContexts(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportedContexts>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ImageEffectHost& setSupportedContexts(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedContexts>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ImageEffectHost& setSupportedContexts(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropSupportedContexts>(values, error_if_missing);
        return *this;
    }

    ImageEffectHost& setMultipleClipDepths(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropMultipleClipDepths>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setOpenCLSupported(const char* value, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectPropOpenCLSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setSupportsMultipleClipPARs(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSupportsMultipleClipPARs>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setSetableFrameRate(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSetableFrameRate>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setSetableFielding(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropSetableFielding>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropSupportsCustomInteract(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamHostPropSupportsCustomInteract>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropSupportsStringAnimation(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamHostPropSupportsStringAnimation>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropSupportsChoiceAnimation(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamHostPropSupportsChoiceAnimation>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropSupportsBooleanAnimation(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamHostPropSupportsBooleanAnimation>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropSupportsCustomAnimation(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamHostPropSupportsCustomAnimation>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropSupportsStrChoice(bool value, bool error_if_missing = false) {
        props_.set<PropId::OfxParamHostPropSupportsStrChoice>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropSupportsStrChoiceAnimation(bool value, bool error_if_missing = false) {
        props_.set<PropId::OfxParamHostPropSupportsStrChoiceAnimation>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropMaxParameters(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamHostPropMaxParameters>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropMaxPages(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamHostPropMaxPages>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropPageRowColumnCount(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamHostPropPageRowColumnCount>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    ImageEffectHost& setParamHostPropPageRowColumnCount(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxParamHostPropPageRowColumnCount>(values, error_if_missing);
        return *this;
    }

    ImageEffectHost& setHostOSHandle(void* value, bool error_if_missing = false) {
        props_.set<PropId::OfxPropHostOSHandle>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setParamHostPropSupportsParametricAnimation(bool value, bool error_if_missing = false) {
        props_.set<PropId::OfxParamHostPropSupportsParametricAnimation>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setImageEffectInstancePropSequentialRender(bool value, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectInstancePropSequentialRender>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setOpenGLRenderSupported(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxImageEffectPropOpenGLRenderSupported>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setRenderQualityDraft(bool value, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectPropRenderQualityDraft>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setImageEffectHostPropNativeOrigin(const char* value, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectHostPropNativeOrigin>(value, 0, error_if_missing);
        return *this;
    }

    ImageEffectHost& setColourManagementAvailableConfigs(const char* value, int index = 0, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectPropColourManagementAvailableConfigs>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    ImageEffectHost& setColourManagementAvailableConfigs(const Container& values, bool error_if_missing = false) {
        props_.setAll<PropId::OfxImageEffectPropColourManagementAvailableConfigs>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    ImageEffectHost& setColourManagementAvailableConfigs(std::initializer_list<const char*> values, bool error_if_missing = false) {
        props_.setAll<PropId::OfxImageEffectPropColourManagementAvailableConfigs>(values, error_if_missing);
        return *this;
    }

    ImageEffectHost& setColourManagementStyle(const char* value, bool error_if_missing = false) {
        props_.set<PropId::OfxImageEffectPropColourManagementStyle>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractActionDraw_InArgs
class InteractActionDraw_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractActionDraw_InArgs& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionDraw_InArgs& setInteractPropDrawContext(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxInteractPropDrawContext>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionDraw_InArgs& setInteractPropPixelScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionDraw_InArgs& setInteractPropPixelScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    InteractActionDraw_InArgs& setInteractPropBackgroundColour(const std::array<double, 3>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionDraw_InArgs& setInteractPropBackgroundColour(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    InteractActionDraw_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionDraw_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionDraw_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractActionGainFocus_InArgs
class InteractActionGainFocus_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractActionGainFocus_InArgs& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionGainFocus_InArgs& setInteractPropPixelScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionGainFocus_InArgs& setInteractPropPixelScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    InteractActionGainFocus_InArgs& setInteractPropBackgroundColour(const std::array<double, 3>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionGainFocus_InArgs& setInteractPropBackgroundColour(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    InteractActionGainFocus_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionGainFocus_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionGainFocus_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractActionKeyDown_InArgs
class InteractActionKeyDown_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractActionKeyDown_InArgs& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyDown_InArgs& setKeySym(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropKeySym>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyDown_InArgs& setKeyString(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropKeyString>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyDown_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyDown_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionKeyDown_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractActionKeyRepeat_InArgs
class InteractActionKeyRepeat_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractActionKeyRepeat_InArgs& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyRepeat_InArgs& setKeySym(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropKeySym>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyRepeat_InArgs& setKeyString(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropKeyString>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyRepeat_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyRepeat_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionKeyRepeat_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractActionKeyUp_InArgs
class InteractActionKeyUp_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractActionKeyUp_InArgs& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyUp_InArgs& setKeySym(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropKeySym>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyUp_InArgs& setKeyString(const char* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropKeyString>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyUp_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionKeyUp_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionKeyUp_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractActionLoseFocus_InArgs
class InteractActionLoseFocus_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractActionLoseFocus_InArgs& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionLoseFocus_InArgs& setInteractPropPixelScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionLoseFocus_InArgs& setInteractPropPixelScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    InteractActionLoseFocus_InArgs& setInteractPropBackgroundColour(const std::array<double, 3>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionLoseFocus_InArgs& setInteractPropBackgroundColour(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    InteractActionLoseFocus_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionLoseFocus_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionLoseFocus_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractActionPenDown_InArgs
class InteractActionPenDown_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractActionPenDown_InArgs& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionPenDown_InArgs& setInteractPropPixelScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenDown_InArgs& setInteractPropPixelScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    InteractActionPenDown_InArgs& setInteractPropBackgroundColour(const std::array<double, 3>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenDown_InArgs& setInteractPropBackgroundColour(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    InteractActionPenDown_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionPenDown_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenDown_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    InteractActionPenDown_InArgs& setInteractPropPenPosition(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenPosition>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenDown_InArgs& setInteractPropPenPosition(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenPosition>(values, error_if_missing);
        return *this;
    }

    InteractActionPenDown_InArgs& setInteractPropPenViewportPosition(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenViewportPosition>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenDown_InArgs& setInteractPropPenViewportPosition(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenViewportPosition>(values, error_if_missing);
        return *this;
    }

    InteractActionPenDown_InArgs& setInteractPropPenPressure(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxInteractPropPenPressure>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractActionPenMotion_InArgs
class InteractActionPenMotion_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractActionPenMotion_InArgs& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionPenMotion_InArgs& setInteractPropPixelScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenMotion_InArgs& setInteractPropPixelScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    InteractActionPenMotion_InArgs& setInteractPropBackgroundColour(const std::array<double, 3>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenMotion_InArgs& setInteractPropBackgroundColour(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    InteractActionPenMotion_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionPenMotion_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenMotion_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    InteractActionPenMotion_InArgs& setInteractPropPenPosition(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenPosition>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenMotion_InArgs& setInteractPropPenPosition(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenPosition>(values, error_if_missing);
        return *this;
    }

    InteractActionPenMotion_InArgs& setInteractPropPenViewportPosition(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenViewportPosition>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenMotion_InArgs& setInteractPropPenViewportPosition(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenViewportPosition>(values, error_if_missing);
        return *this;
    }

    InteractActionPenMotion_InArgs& setInteractPropPenPressure(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxInteractPropPenPressure>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractActionPenUp_InArgs
class InteractActionPenUp_InArgs : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractActionPenUp_InArgs& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionPenUp_InArgs& setInteractPropPixelScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenUp_InArgs& setInteractPropPixelScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    InteractActionPenUp_InArgs& setInteractPropBackgroundColour(const std::array<double, 3>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenUp_InArgs& setInteractPropBackgroundColour(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    InteractActionPenUp_InArgs& setTime(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropTime>(value, 0, error_if_missing);
        return *this;
    }

    InteractActionPenUp_InArgs& setRenderScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenUp_InArgs& setRenderScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxImageEffectPropRenderScale>(values, error_if_missing);
        return *this;
    }

    InteractActionPenUp_InArgs& setInteractPropPenPosition(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenPosition>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenUp_InArgs& setInteractPropPenPosition(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenPosition>(values, error_if_missing);
        return *this;
    }

    InteractActionPenUp_InArgs& setInteractPropPenViewportPosition(const std::array<int, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenViewportPosition>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractActionPenUp_InArgs& setInteractPropPenViewportPosition(std::initializer_list<int> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPenViewportPosition>(values, error_if_missing);
        return *this;
    }

    InteractActionPenUp_InArgs& setInteractPropPenPressure(double value, bool error_if_missing = true) {
        props_.set<PropId::OfxInteractPropPenPressure>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractDescriptor
class InteractDescriptor : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractDescriptor& setInteractPropHasAlpha(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxInteractPropHasAlpha>(value, 0, error_if_missing);
        return *this;
    }

    InteractDescriptor& setInteractPropBitDepth(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxInteractPropBitDepth>(value, 0, error_if_missing);
        return *this;
    }

};

// Property set accessor for: InteractInstance
class InteractInstance : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    InteractInstance& setEffectInstance(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropEffectInstance>(value, 0, error_if_missing);
        return *this;
    }

    InteractInstance& setInstanceData(void* value, bool error_if_missing = true) {
        props_.set<PropId::OfxPropInstanceData>(value, 0, error_if_missing);
        return *this;
    }

    InteractInstance& setInteractPropPixelScale(const std::array<double, 2>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractInstance& setInteractPropPixelScale(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropPixelScale>(values, error_if_missing);
        return *this;
    }

    InteractInstance& setInteractPropBackgroundColour(const std::array<double, 3>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractInstance& setInteractPropBackgroundColour(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropBackgroundColour>(values, error_if_missing);
        return *this;
    }

    InteractInstance& setInteractPropHasAlpha(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxInteractPropHasAlpha>(value, 0, error_if_missing);
        return *this;
    }

    InteractInstance& setInteractPropBitDepth(int value, bool error_if_missing = true) {
        props_.set<PropId::OfxInteractPropBitDepth>(value, 0, error_if_missing);
        return *this;
    }

    InteractInstance& setInteractPropSlaveToParam(const char* value, int index = 0, bool error_if_missing = true) {
        props_.set<PropId::OfxInteractPropSlaveToParam>(value, index, error_if_missing);
        return *this;
    }

    // Set all values from a container (vector, array, span, etc.)
    // SFINAE: only enabled for container types (not scalars)
    template<typename Container,
             typename = std::enable_if_t<!std::is_arithmetic_v<Container> && !std::is_pointer_v<Container>>>
    InteractInstance& setInteractPropSlaveToParam(const Container& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropSlaveToParam>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2, 3})
    InteractInstance& setInteractPropSlaveToParam(std::initializer_list<const char*> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropSlaveToParam>(values, error_if_missing);
        return *this;
    }

    InteractInstance& setInteractPropSuggestedColour(const std::array<double, 3>& values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropSuggestedColour>(values, error_if_missing);
        return *this;
    }

    // Set all values from an initializer list (e.g., {1, 2})
    InteractInstance& setInteractPropSuggestedColour(std::initializer_list<double> values, bool error_if_missing = true) {
        props_.setAll<PropId::OfxInteractPropSuggestedColour>(values, error_if_missing);
        return *this;
    }

};

// Property set accessor for: ParamDouble1D
class ParamDouble1D : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    bool showTimeMarker(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropShowTimeMarker>(0, error_if_missing);
    }

    const char* doubleType(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDoubleType>(0, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    ParamDouble1D& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamDouble1D& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T min(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> minAll() const {
        return props_.getAll<PropId::OfxParamPropMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T max(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> maxAll() const {
        return props_.getAll<PropId::OfxParamPropMax, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMin(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMinAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMax(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMaxAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMax, T>();
    }

    double increment(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIncrement>(0, error_if_missing);
    }

    int digits(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDigits>(0, error_if_missing);
    }

};

// Property set accessor for: ParameterSet
class ParameterSet : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    bool paramSetNeedsSyncing(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropParamSetNeedsSyncing>(0, error_if_missing);
    }

    const char* paramPageOrder(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxPluginPropParamPageOrder>(index, error_if_missing);
    }

};

// Property set accessor for: ParamsByte
class ParamsByte : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    ParamsByte& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamsByte& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T min(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> minAll() const {
        return props_.getAll<PropId::OfxParamPropMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T max(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> maxAll() const {
        return props_.getAll<PropId::OfxParamPropMax, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMin(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMinAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMax(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMaxAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMax, T>();
    }

};

// Property set accessor for: ParamsChoice
class ParamsChoice : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* choiceOption(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropChoiceOption>(index, error_if_missing);
    }

    int choiceOrder(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropChoiceOrder>(index, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    ParamsChoice& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamsChoice& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

};

// Property set accessor for: ParamsCustom
class ParamsCustom : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    void* customCallbackV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCustomCallbackV1>(0, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    ParamsCustom& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamsCustom& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

};

// Property set accessor for: ParamsDouble2D3D
class ParamsDouble2D3D : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* doubleType(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDoubleType>(0, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    ParamsDouble2D3D& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamsDouble2D3D& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T min(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> minAll() const {
        return props_.getAll<PropId::OfxParamPropMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T max(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> maxAll() const {
        return props_.getAll<PropId::OfxParamPropMax, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMin(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMinAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMax(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMaxAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMax, T>();
    }

    double increment(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIncrement>(0, error_if_missing);
    }

    int digits(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDigits>(0, error_if_missing);
    }

};

// Property set accessor for: ParamsGroup
class ParamsGroup : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    bool groupOpen(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropGroupOpen>(0, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

};

// Property set accessor for: ParamsInt2D3D
class ParamsInt2D3D : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* dimensionLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDimensionLabel>(0, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    ParamsInt2D3D& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamsInt2D3D& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T min(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> minAll() const {
        return props_.getAll<PropId::OfxParamPropMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T max(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> maxAll() const {
        return props_.getAll<PropId::OfxParamPropMax, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMin(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMinAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMax(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMaxAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMax, T>();
    }

};

// Property set accessor for: ParamsNormalizedSpatial
class ParamsNormalizedSpatial : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* defaultCoordinateSystem(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefaultCoordinateSystem>(0, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    ParamsNormalizedSpatial& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamsNormalizedSpatial& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T min(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> minAll() const {
        return props_.getAll<PropId::OfxParamPropMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T max(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> maxAll() const {
        return props_.getAll<PropId::OfxParamPropMax, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMin(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMinAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMax(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMaxAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMax, T>();
    }

    double increment(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIncrement>(0, error_if_missing);
    }

    int digits(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDigits>(0, error_if_missing);
    }

};

// Property set accessor for: ParamsPage
class ParamsPage : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* pageChild(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPageChild>(index, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

};

// Property set accessor for: ParamsParametric
class ParamsParametric : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    bool isAnimating(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAnimating>(0, error_if_missing);
    }

    bool isAutoKeying(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropIsAutoKeying>(0, error_if_missing);
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

    int parametricDimension(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParametricDimension>(0, error_if_missing);
    }

    double parametricUIColour(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParametricUIColour>(index, error_if_missing);
    }

    void* parametricInteractBackground(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParametricInteractBackground>(0, error_if_missing);
    }

    std::array<double, 2> parametricRange() const {
        return props_.getAll<PropId::OfxParamPropParametricRange>();
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

};

// Property set accessor for: ParamsStrChoice
class ParamsStrChoice : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* choiceOption(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropChoiceOption>(index, error_if_missing);
    }

    bool choiceEnum(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropChoiceEnum>(0, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    ParamsStrChoice& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamsStrChoice& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

};

// Property set accessor for: ParamsString
class ParamsString : public PropertySetAccessor {
public:
    using PropertySetAccessor::PropertySetAccessor;

    const char* stringMode(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropStringMode>(0, error_if_missing);
    }

    bool stringFilePathExists(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropStringFilePathExists>(0, error_if_missing);
    }

    const char* type(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropType>(0, error_if_missing);
    }

    const char* name(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropName>(0, error_if_missing);
    }

    const char* label(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLabel>(0, error_if_missing);
    }

    const char* shortLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropShortLabel>(0, error_if_missing);
    }

    const char* longLabel(bool error_if_missing = true) const {
        return props_.get<PropId::OfxPropLongLabel>(0, error_if_missing);
    }

    bool secret(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropSecret>(0, error_if_missing);
    }

    const char* hint(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHint>(0, error_if_missing);
    }

    const char* scriptName(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropScriptName>(0, error_if_missing);
    }

    const char* parent(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropParent>(0, error_if_missing);
    }

    bool enabled(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEnabled>(0, error_if_missing);
    }

    void* dataPtr(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDataPtr>(0, error_if_missing);
    }

    std::array<const char*, 2> icon() const {
        return props_.getAll<PropId::OfxPropIcon>();
    }

    void* interactV1(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractV1>(0, error_if_missing);
    }

    std::array<double, 2> interactSize() const {
        return props_.getAll<PropId::OfxParamPropInteractSize>();
    }

    double interactSizeAspect(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropInteractSizeAspect>(0, error_if_missing);
    }

    std::array<double, 2> interactMinimumSize() const {
        return props_.getAll<PropId::OfxParamPropInteractMinimumSize>();
    }

    std::array<int, 2> interactPreferedSize() const {
        return props_.getAll<PropId::OfxParamPropInteractPreferedSize>();
    }

    bool hasHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropHasHostOverlayHandle>(0, error_if_missing);
    }

    bool useHostOverlayHandle(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropUseHostOverlayHandle>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double, string, pointer)
    template<typename T>
    T default(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDefault, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> defaultAll() const {
        return props_.getAll<PropId::OfxParamPropDefault, T>();
    }

    bool animates(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropAnimates>(0, error_if_missing);
    }

    ParamsString& setIsAnimating(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAnimating>(value, 0, error_if_missing);
        return *this;
    }

    ParamsString& setIsAutoKeying(bool value, bool error_if_missing = true) {
        props_.set<PropId::OfxParamPropIsAutoKeying>(value, 0, error_if_missing);
        return *this;
    }

    bool persistant(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPersistant>(0, error_if_missing);
    }

    bool evaluateOnChange(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropEvaluateOnChange>(0, error_if_missing);
    }

    bool pluginMayWrite(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropPluginMayWrite>(0, error_if_missing);
    }

    const char* cacheInvalidation(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCacheInvalidation>(0, error_if_missing);
    }

    bool canUndo(bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropCanUndo>(0, error_if_missing);
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T min(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> minAll() const {
        return props_.getAll<PropId::OfxParamPropMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T max(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> maxAll() const {
        return props_.getAll<PropId::OfxParamPropMax, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMin(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMin, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMinAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMin, T>();
    }

    // Multi-type property (supports: int, double)
    template<typename T>
    T displayMax(int index = 0, bool error_if_missing = true) const {
        return props_.get<PropId::OfxParamPropDisplayMax, T>(index, error_if_missing);
    }

    template<typename T>
    std::vector<T> displayMaxAll() const {
        return props_.getAll<PropId::OfxParamPropDisplayMax, T>();
    }

};

} // namespace openfx
