# Copyright OpenFX and contributors to the OpenFX project.
# SPDX-License-Identifier: BSD-3-Clause

import os
import re
import sys
import difflib
import argparse
import yaml
import logging
from pathlib import Path
from collections.abc import Iterable

# Set up basic configuration for logging
logging.basicConfig(
    level=logging.INFO,  # Log level: DEBUG, INFO, WARNING, ERROR, CRITICAL
    format='%(levelname)s: %(message)s',  # Format of the log messages
    datefmt='%Y-%m-%d %H:%M:%S'  # Date format
)

# Global vars and config

generated_source_header = """// Copyright OpenFX and contributors to the OpenFX project.
// SPDX-License-Identifier: BSD-3-Clause
// NOTE: This file is auto-generated by gen-props.py. DO NOT EDIT.
"""


def getPropertiesFromFile(path):
    """Get all OpenFX property definitions from C header file.

    Uses a heuristic to identify property #define lines:
    anything starting with '#define' and containing 'Prop' in the name.
    """
    props = set()
    with open(path) as f:
        try:
            lines = f.readlines()
        except UnicodeDecodeError as e:
            logging.error(f'error reading {path}: {e}')
            raise e
        for l in lines:
            # Detect lines that correspond to a property definition, e.g:
            # #define kOfxPropLala "OfxPropLala"
            splits=l.split()
            if len(splits) < 3:
                continue
            if splits[0] != '#define':
                continue
            # ignore these
            nonProperties = ('kOfxPropertySuite',
                             # prop values, not props
                             'kOfxImageEffectPropColourManagementNone',
                             'kOfxImageEffectPropColourManagementBasic',
                             'kOfxImageEffectPropColourManagementCore',
                             'kOfxImageEffectPropColourManagementFull',
                             'kOfxImageEffectPropColourManagementOCIO',
                             )
            if splits[1] in nonProperties:
                continue
            # these are props, as well as anything with Prop in the name
            badlyNamedProperties = ("kOfxImageEffectFrameVarying",
                                    "kOfxImageEffectPluginRenderThreadSafety")
            if 'Prop' in splits[1] \
               or any(s in splits[1] for s in badlyNamedProperties):
                props.add(splits[1])
    return props

def getPropertiesFromDir(dir):
    """
    Recursively get all property definitions from source files in a dir.
    """

    extensions = {'.c', '.h', '.cxx', '.hxx', '.cpp', '.hpp'}

    props = set()
    for root, _dirs, files in os.walk(dir):
        for file in files:
            # Get the file extension
            file_extension = os.path.splitext(file)[1]

            if file_extension in extensions:
                file_path = os.path.join(root, file)
                props |= getPropertiesFromFile(file_path)
    return list(props)

def get_def(name: str, defs):
    if name.endswith('_REF'):
        defname = name.replace("_REF", "_DEF")
        return defs[defname]
    else:
        return [name]

def expand_set_props(props_by_set):
    """Expand refs in props_by_sets.
    YAML can't interpolate a list, so we do it here, using
    our own method:
    - A prop set may end with _DEF in which case it's just a definition
      containing a list of prop names.
    - A prop *name* may be <name>_REF which means to interpolate the
      corresponding DEF list into this set's props.
    Returns a new props_by_set with DEFs removed and all lists interpolated.
    """
    # First get all the list defs
    defs = {}
    sets = {}
    for key, value in props_by_set.items():
        if key.endswith('_DEF'):
            defs[key] = value   # should be a list to be interpolated
        else:
            sets[key] = value
    for key in sets:
        if not sets[key].get('props'):
            pass # do nothing, no expansion needed in inArgs/outArgs for now
        else:
            sets[key]['props'] = [item for element in sets[key]['props'] \
                         for item in get_def(element, defs)]
    return sets

def get_cname(propname, props_metadata):
    """Get the C `#define` name for a property name.

    Look up the special cname in props_metadata, or in the normal
    case just prepend "k".
    """
    return props_metadata[propname].get('cname', "k" + propname)

def find_stringname(cname, props_metadata):
    """Try to find the actual string corresponding to the C #define name.
    This may be slow; looks through all the metadata for a matching
    "cname", otherwise strips "k".
    """
    for p in props_metadata:
        if props_metadata[p].get('cname') == cname:
            return p
    if cname.startswith("k"):
        return cname[1:]
    return "unknown-stringname-for-" + cname

def find_missing(all_props, props_metadata):
    """Find and print all mismatches between prop defs and metadata.

    Returns 0 if no errors.
    """
    errs = 0
    for p in sorted(all_props): # constants from #include files, with "k" prefix
        stringval = find_stringname(p, props_metadata)
        if not props_metadata.get(stringval):
            logging.error(f"No YAML metadata found for {p}")
            errs += 1
    for p in sorted(props_metadata):
        cname = get_cname(p, props_metadata)
        if cname not in all_props:
            logging.error(f"No prop definition found for '{p}' in source/include")
            matches = difflib.get_close_matches(p, all_props, 3, 0.9)
            if matches:
                logging.info(f" Did you mean: {matches}")
            errs += 1
    return errs

def props_for_set(pset, props_by_set, name_only=True):
    """Generator yielding all props for the given prop set (not used for actions).
    This implements the options override scheme, parsing the prop name etc.
    If not name_only, yields a dict of name and other options.
    """
    if not props_by_set[pset].get('props'):
        return
    # All the default options for this propset. Merged into each prop.
    propset_options = props_by_set[pset].copy()
    propset_options.pop('props', None)
    for p in props_by_set[pset]['props']:
        # Parse p, of form NAME | key=value,key=value
        pattern = r'^\s*(\w+)\s*\|\s*([\w\s,=]*)$'
        match = re.match(pattern, p)
        if not match:
            if name_only:
                yield p
            else:
                yield {**propset_options, **{"name": p}}
            continue
        name = match.group(1)
        if name_only:
            yield name
        else:
            # parse key/value pairs, apply defaults, and include name
            key_values_str = match.group(2)
            if not key_values_str:
                options = {}
            else:
                key_value_pattern = r'(\w+)=([\w-]+)'
                options = dict(re.findall(key_value_pattern, key_values_str))
            yield {**propset_options, **options, **{"name": name}}

def check_props_by_set(props_by_set, props_by_action, props_metadata):
    """Find and print all mismatches between prop set specs, props, and metadata.

    * Each prop name in props_by_set should have a match in props_metadata
    Note that props_by_pset may have multiple levels, e.g. inArgs for an action.
    Returns 0 if no errors.
    """
    errs = 0
    for pset in sorted(props_by_set):
        for p in props_for_set(pset, props_by_set):
            if not props_metadata.get(p):
                logging.error(f"No props metadata found for {pset}.{p}")
                errs += 1
    for pset in sorted(props_by_action):
        # For actions, the value of props_by_set[pset] is a dict, each
        # (e.g. inArgs, outArgs) containing a list of props.
        for subset in sorted(props_by_action[pset]):
            if not props_by_action[pset][subset]:
                continue
            for p in props_by_action[pset][subset]:
                if not props_metadata.get(p):
                    logging.error(f"No props metadata found for action {pset}.{subset}.{p}")
                    errs += 1
    return errs

def check_props_used_by_set(props_by_set, props_by_action, props_metadata):
    """Find and print all mismatches between prop set specs, props, and metadata.

    * Each prop name in props_metadata should be used in at least one set.
    Returns 0 if no errors.
    """
    errs = 0
    for prop in props_metadata:
        found = 0
        for pset in props_by_set:
            for set_prop in props_for_set(pset, props_by_set):
                if set_prop == prop:
                    found += 1
        for pset in props_by_action:
            # inArgs/outArgs
            for subset in sorted(props_by_action[pset]):
                if not props_by_action[pset][subset]:
                    continue
                for set_prop in props_by_action[pset][subset]:
                    if set_prop == prop:
                        found += 1
        if not found and not props_metadata[prop].get('deprecated'):
            logging.error(f"Prop {prop} not used in any prop set in YML file")
    return errs

def gen_props_metadata(props_metadata, outfile_path: Path):
    """Generate a header file with metadata for each prop"""
    with open(outfile_path, 'w') as outfile:
        outfile.write(generated_source_header)
        outfile.write("""
#pragma once

#include <string>
#include <vector>
#include "ofxImageEffect.h"
#include "ofxGPURender.h"
#include "ofxColour.h"
#include "ofxDrawSuite.h"
#include "ofxParametricParam.h"
#include "ofxKeySyms.h"
#include "ofxOld.h"

namespace OpenFX {
enum class PropType {
   Int,
   Double,
   Enum,
   Bool,
   String,
   Bytes,
   Pointer
};

struct PropsMetadata {
  std::string name;
  std::vector<PropType> types;
  int dimension;
  std::vector<const char *> values; // for enums
};

""")
        n_props = len(props_metadata)
        outfile.write(f"static inline const std::array<struct PropsMetadata, {n_props}> props_metadata {{ {{\n")
        for p in sorted(props_metadata):
            try:
                md = props_metadata[p]
                types = md.get('type')
                if isinstance(types, str): # make it always a list
                    types = (types,)
                prop_type_defs = "{" + ",".join(f'PropType::{t.capitalize()}' for t in types) + "}"
                host_opt = md.get('hostOptional', 'false')
                if host_opt in ('True', 'true', 1):
                    host_opt = 'true'
                if host_opt in ('False', 'false', 0):
                    host_opt = 'false'
                if md['type'] == 'enum':
                    assert isinstance(md['values'], list)
                    values = "{" + ",".join(f'\"{v}\"' for v in md['values']) + "}"
                else:
                    values = "{}"
                outfile.write(f"{{ \"{p}\", {prop_type_defs}, {md['dimension']}, "
                              f"{values} }},\n")
            except Exception as e:
                logging.error(f"Error: {p} is missing metadata? {e}")
                raise(e)
        outfile.write("} };\n\n")

        # Generate static asserts to ensure our constants match the string values
        outfile.write("// Static asserts to check #define names vs. strings\n")
        for p in sorted(props_metadata):
            cname = get_cname(p, props_metadata)
            outfile.write(f"static_assert(std::string_view(\"{p}\") == std::string_view({cname}));\n")

        outfile.write("} // namespace OpenFX\n")



def gen_props_by_set(props_by_set, props_by_action, outfile_path: Path):
    """Generate a header file with definitions of all prop sets, including their props"""
    with open(outfile_path, 'w') as outfile:
        outfile.write(generated_source_header)
        outfile.write("""
#pragma once

#include <string>
#include <vector>
#include <map>
#include <array>
#include "ofxImageEffect.h"
#include "ofxGPURender.h"
#include "ofxColour.h"
#include "ofxDrawSuite.h"
#include "ofxParametricParam.h"
#include "ofxKeySyms.h"
// #include "ofxOld.h"

namespace OpenFX {

struct Prop {
  const char *name;
  bool host_write;
  bool plugin_write;
  bool host_optional;
};

""")
        outfile.write("// Properties for property sets\n")
        outfile.write("static inline const std::map<const char *, std::vector<Prop>> prop_sets {\n")

        for pset in sorted(props_by_set.keys()):
            propdefs = []
            for p in props_for_set(pset, props_by_set, False):
                host_write = 'true' if p['write'] in ('host', 'all') else 'false'
                plugin_write = 'true' if p['write'] in ('plugin', 'all') else 'false'
                propdefs.append(f"{{ \"{p['name']}\", {host_write} , {plugin_write}, false }}")
            propdefs_str = ",\n   ".join(propdefs)
            outfile.write(f"{{ \"{pset}\", {{ {propdefs_str} }} }},\n")
        outfile.write("};\n\n")

        actions = sorted(props_by_action.keys())

        outfile.write("// Actions\n")
        outfile.write(f"static inline const std::array<const char *, {len(actions)}> actions {{\n")
        for pset in actions:
            if not pset.startswith("kOfx"):
                pset = '"' + pset + '"'   # quote if it's not a known constant
            outfile.write(f"  {pset},\n")
        outfile.write("};\n\n")

        outfile.write("// Properties for action args\n")
        outfile.write("static inline const std::map<std::array<std::string, 2>, std::vector<const char *>> action_props {\n")
        for pset in actions:
            for subset in props_by_action[pset]:
                if not props_by_action[pset][subset]:
                    continue
                propnames = ",\n   ".join(sorted([f'"{p}"' for p in props_by_action[pset][subset]]))
                if not pset.startswith("kOfx"):
                    psetname = '"' + pset + '"'   # quote if it's not a known constant
                else:
                    psetname = pset
                outfile.write(f"{{ {{ {psetname}, \"{subset}\" }}, {{ {propnames} }} }},\n")

        outfile.write("};\n\n")

        outfile.write("// Static asserts for standard action names\n")
        for pset in actions:
            if not pset.startswith("Ofx"):
                continue
            outfile.write(f"static_assert(std::string_view(\"{pset}\") == std::string_view(k{pset}));\n")

        outfile.write("} // namespace OpenFX\n")

def main(args):
    script_dir = os.path.dirname(os.path.abspath(__file__))
    include_dir = Path(script_dir).parent / 'include'
    all_props = getPropertiesFromDir(include_dir)
    logging.info(f'Got {len(all_props)} props from "include" dir')

    with open(include_dir / 'ofx-props.yml', 'r') as props_file:
        props_data = yaml.safe_load(props_file)
    props_by_set = expand_set_props(props_data['propertySets'])
    props_by_action = props_data['Actions']
    props_metadata = props_data['properties']

    if args.verbose:
        print("\n=== Checking ofx-props.yml: should map 1:1 to props found in source/header files")
    errs = find_missing(all_props, props_metadata)
    if not errs and args.verbose:
        print(" ✔️ ALL OK")

    if args.verbose:
        print("\n=== Checking ofx-props.yml: every prop in a set should have metadata in the YML file")
    errs = check_props_by_set(props_by_set, props_by_action, props_metadata)
    if not errs and args.verbose:
        print(" ✔️ ALL OK")

    if args.verbose:
        print("\n=== Checking ofx-props.yml: every prop should be used in in at least one set in the YML file")
    errs = check_props_used_by_set(props_by_set, props_by_action, props_metadata)
    if not errs and args.verbose:
        print(" ✔️ ALL OK")

    if args.verbose:
        print(f"=== Generating {args.props_metadata}")
    gen_props_metadata(props_metadata, support_include_dir / args.props_metadata)

    if args.verbose:
        print(f"=== Generating {args.props_metadata}")
    gen_props_metadata(props_metadata, support_include_dir / args.props_metadata)

    if args.verbose:
        print(f"=== Generating props by set header {args.props_by_set}")
    gen_props_by_set(props_by_set, props_by_action, support_include_dir / args.props_by_set)

if __name__ == "__main__":
    script_dir = os.path.dirname(os.path.abspath(__file__))
    support_include_dir = Path(script_dir).parent / 'Support/include'
    parser = argparse.ArgumentParser(description="Check OpenFX properties and generate ancillary data structures",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Define arguments here
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode')
    parser.add_argument('--props-metadata', default=support_include_dir/"ofxPropsMetadata.h",
                        help="Generate property metadata into this file")
    parser.add_argument('--props-by-set', default=support_include_dir/"ofxPropsBySet.h",
                        help="Generate props by set metadata into this file")

    # Parse the arguments
    args = parser.parse_args()

    # Call the main function with parsed arguments
    main(args)
