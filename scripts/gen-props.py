# Copyright OpenFX and contributors to the OpenFX project.
# SPDX-License-Identifier: BSD-3-Clause

# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "pyyaml>=1.0",
# ]
# ///

import os
import re
import sys
import difflib
import argparse
import yaml
import logging
from pathlib import Path
from collections.abc import Iterable

# Set up basic configuration for logging
logging.basicConfig(
    level=logging.INFO,  # Log level: DEBUG, INFO, WARNING, ERROR, CRITICAL
    format='%(levelname)s: %(message)s',  # Format of the log messages
    datefmt='%Y-%m-%d %H:%M:%S'  # Date format
)

# Global vars and config

generated_source_header = """// Copyright OpenFX and contributors to the OpenFX project.
// SPDX-License-Identifier: BSD-3-Clause
// NOTE: This file is auto-generated by gen-props.py. DO NOT EDIT.
"""


def getPropertiesFromFile(path):
    """Get all OpenFX property definitions from C header file.

    Uses a heuristic to identify property #define lines:
    anything starting with '#define' and containing 'Prop' in the name.
    """
    props = set()
    with open(path) as f:
        try:
            lines = f.readlines()
        except UnicodeDecodeError as e:
            logging.error(f'error reading {path}: {e}')
            raise e
        for l in lines:
            # Detect lines that correspond to a property definition, e.g:
            # #define kOfxPropLala "OfxPropLala"
            splits=l.split()
            if len(splits) < 3:
                continue
            if splits[0] != '#define':
                continue
            # ignore these
            nonProperties = ('kOfxPropertySuite',
                             # prop values, not props
                             'kOfxImageEffectPropColourManagementNone',
                             'kOfxImageEffectPropColourManagementBasic',
                             'kOfxImageEffectPropColourManagementCore',
                             'kOfxImageEffectPropColourManagementFull',
                             'kOfxImageEffectPropColourManagementOCIO',
                             )
            if splits[1] in nonProperties:
                continue
            # these are props, as well as anything with Prop in the name
            badlyNamedProperties = ("kOfxImageEffectFrameVarying",
                                    "kOfxImageEffectPluginRenderThreadSafety")
            if 'Prop' in splits[1] \
               or any(s in splits[1] for s in badlyNamedProperties):
                props.add(splits[1])
    return props

def getPropertiesFromDir(dir):
    """
    Recursively get all property definitions from source files in a dir.
    """

    extensions = {'.c', '.h', '.cxx', '.hxx', '.cpp', '.hpp'}

    props = set()
    for root, _dirs, files in os.walk(dir):
        for file in files:
            # Get the file extension
            file_extension = os.path.splitext(file)[1]

            if file_extension in extensions:
                file_path = os.path.join(root, file)
                props |= getPropertiesFromFile(file_path)
    return list(props)

def get_def(name: str, defs):
    if name.endswith('_REF'):
        defname = name.replace("_REF", "_DEF")
        return defs[defname]
    else:
        return [name]

def expand_set_props(props_by_set):
    """Expand refs in props_by_sets.
    YAML can't interpolate a list, so we do it here, using
    our own method:
    - A prop set may end with _DEF in which case it's just a definition
      containing a list of prop names.
    - A prop *name* may be <name>_REF which means to interpolate the
      corresponding DEF list into this set's props.
    Returns a new props_by_set with DEFs removed and all lists interpolated.
    """
    # First get all the list defs
    defs = {}
    sets = {}
    for key, value in props_by_set.items():
        if key.endswith('_DEF'):
            defs[key] = value   # should be a list to be interpolated
        else:
            sets[key] = value
    for key in sets:
        if not sets[key].get('props'):
            pass # do nothing, no expansion needed in inArgs/outArgs for now
        else:
            sets[key]['props'] = [item for element in sets[key]['props'] \
                         for item in get_def(element, defs)]
    return sets

def get_cname(propname, props_metadata):
    """Get the C `#define` name for a property name.

    Look up the special cname in props_metadata, or in the normal
    case just prepend "k".
    """
    return props_metadata[propname].get('cname', "k" + propname)

def get_prop_id(propname):
    """HACK ALERT: a few props' names (string values) start with k.
    Those are also the #define names. If we use those as PropId enum
    values, they'll get expanded into the strings which will lead to
    compile errors. This means the names to be looked up always don't
    have the "k". We could prefix them or something but this should be
    OK. """
    if propname.startswith("k"):
        return propname[1:]
    return propname

def find_stringname(cname, props_metadata):
    """Try to find the actual string corresponding to the C #define name.
    This may be slow; looks through all the metadata for a matching
    "cname", otherwise strips "k".
    """
    for p in props_metadata:
        if props_metadata[p].get('cname') == cname:
            return p
    if cname.startswith("k"):
        return cname[1:]
    return "unknown-stringname-for-" + cname

def find_missing(all_props, props_metadata):
    """Find and print all mismatches between prop defs and metadata.

    Returns 0 if no errors.
    """
    errs = 0
    for p in sorted(all_props): # constants from #include files, with "k" prefix
        stringval = find_stringname(p, props_metadata)
        if not props_metadata.get(stringval):
            logging.error(f"No YAML metadata found for {p}")
            errs += 1
    for p in sorted(props_metadata):
        cname = get_cname(p, props_metadata)
        if cname not in all_props:
            logging.error(f"No prop definition found for '{p}' in source/include")
            matches = difflib.get_close_matches(p, all_props, 3, 0.9)
            if matches:
                logging.info(f" Did you mean: {matches}")
            errs += 1
    return errs

def props_for_set(pset, props_by_set, name_only=True):
    """Generator yielding all props for the given prop set (not used for actions).
    This implements the options override scheme, parsing the prop name etc.
    If not name_only, yields a dict of name and other options.
    """
    if not props_by_set[pset].get('props'):
        return
    # All the default options for this propset. Merged into each prop.
    propset_options = props_by_set[pset].copy()
    propset_options.pop('props', None)
    for p in props_by_set[pset]['props']:
        # Parse p, of form NAME | key=value,key=value
        pattern = r'^\s*(\w+)\s*\|\s*([\w\s,=]*)$'
        match = re.match(pattern, p)
        if not match:
            if name_only:
                yield p
            else:
                yield {**propset_options, **{"name": p}}
            continue
        name = match.group(1)
        if name_only:
            yield name
        else:
            # parse key/value pairs, apply defaults, and include name
            key_values_str = match.group(2)
            if not key_values_str:
                options = {}
            else:
                key_value_pattern = r'(\w+)=([\w-]+)'
                options = dict(re.findall(key_value_pattern, key_values_str))
            yield {**propset_options, **options, **{"name": name}}

def check_props_by_set(props_by_set, props_by_action, props_metadata):
    """Find and print all mismatches between prop set specs, props, and metadata.

    * Each prop name in props_by_set should have a match in props_metadata
    Note that props_by_pset may have multiple levels, e.g. inArgs for an action.
    Returns 0 if no errors.
    """
    errs = 0
    for pset in sorted(props_by_set):
        for p in props_for_set(pset, props_by_set):
            if not props_metadata.get(p):
                logging.error(f"No props metadata found for {pset}.{p}")
                errs += 1
    for pset in sorted(props_by_action):
        # For actions, the value of props_by_set[pset] is a dict, each
        # (e.g. inArgs, outArgs) containing a list of props.
        for subset in sorted(props_by_action[pset]):
            if not props_by_action[pset][subset]:
                continue
            for p in props_by_action[pset][subset]:
                if not props_metadata.get(p):
                    logging.error(f"No props metadata found for action {pset}.{subset}.{p}")
                    errs += 1
    return errs

def check_props_used_by_set(props_by_set, props_by_action, props_metadata):
    """Find and print all mismatches between prop set specs, props, and metadata.

    * Each prop name in props_metadata should be used in at least one set.
    Returns 0 if no errors.
    """
    errs = 0
    for prop in props_metadata:
        found = 0
        for pset in props_by_set:
            for set_prop in props_for_set(pset, props_by_set):
                if set_prop == prop:
                    found += 1
        for pset in props_by_action:
            # inArgs/outArgs
            for subset in sorted(props_by_action[pset]):
                if not props_by_action[pset][subset]:
                    continue
                for set_prop in props_by_action[pset][subset]:
                    if set_prop == prop:
                        found += 1
        if not found and not props_metadata[prop].get('deprecated'):
            logging.error(f"Prop {prop} not used in any prop set in YML file")
    return errs

def gen_props_metadata(props_metadata, outfile_path: Path):
    """Generate a header file with metadata for each prop"""
    with open(outfile_path, 'w') as outfile:
        outfile.write(generated_source_header)
        outfile.write("""
#pragma once

#include <vector>
#include "ofxImageEffect.h"
#include "ofxGPURender.h"
#include "ofxColour.h"
#include "ofxDrawSuite.h"
#include "ofxParametricParam.h"
#include "ofxKeySyms.h"
#include "ofxOld.h"

namespace OpenFX {
enum class PropType {
   Int,
   Double,
   Enum,
   Bool,
   String,
   Pointer
};

// Each prop has a PropId::<propname> enum, a runtime-accessible PropDef struct, and a compile-time PropTraits<id>.
// These can be used by Support/include/PropsAccess.h for type-safe property access.

""")
        outfile.write(f"//Property ID enum for compile-time lookup and type safety\n")
        outfile.write(f"enum class PropId {{\n")
        id = 0
        for p in sorted(props_metadata):
            pname = get_prop_id(p)
            orig_name_msg = ''
            if pname != p:
                orig_name_msg = f" (orig name: {pname})"
            outfile.write(f"  {pname}, // {id}{orig_name_msg}\n")
            id += 1
        outfile.write(f"  NProps // {id}\n")
        outfile.write("}; // PropId\n\n")

        # Property enum values (for enums only)

        outfile.write("// Separate arrays for enum-values for enum props, to keep everything constexpr\n")
        outfile.write("namespace prop_enum_values {\n")
        for p in sorted(props_metadata):
            md = props_metadata[p]
            if md['type'] == 'enum':
                values = "{" + ",".join(f'\"{v}\"' for v in md['values']) + "}"
                outfile.write(f"constexpr std::array {p} =\n  {values};\n")
        outfile.write("} // namespace prop_enum_values\n");

        # Property definitions

        outfile.write("""

#define MAX_PROP_TYPES 4
struct PropDef {
   const char* name;                        // Property name
   PropId id;                               // ID for known props
   PropType supportedTypes[MAX_PROP_TYPES]; // Supported data types
   size_t supportedTypesCount;
   int dimension;                           // Property dimension (0 for variable)
   const char* const* enumValues;           // Valid values for enum properties
   size_t enumValuesCount;
};

// Property definitions
static inline constexpr std::array<PropDef, static_cast<size_t>(PropId::NProps)> prop_defs = {{
""")

        for p in sorted(props_metadata):
            try:
                # name and id
                prop_def = f"{{ \"{p}\", PropId::{get_prop_id(p)}, "
                md = props_metadata[p]
                types = md.get('type')
                if isinstance(types, str): # make it always a list
                    types = (types,)
                # types
                prop_type_defs = "{" + ",".join(f'PropType::{t.capitalize()}' for t in types) + "}"
                prop_def += prop_type_defs + f', {len(types)}, '
                # dimension
                prop_def += f"{md['dimension']}, "
                # enum values
                if md['type'] == 'enum':
                    assert isinstance(md['values'], list)
                    prop_def += f"prop_enum_values::{p}.data(), prop_enum_values::{p}.size()"
                else:
                    prop_def += "nullptr, 0"
                prop_def += "},\n"
                outfile.write(prop_def)
            except Exception as e:
                logging.error(f"Error: {p} is missing metadata? {e}")
                raise(e)
        outfile.write("}};\n\n")

        outfile.write("""
//Template specializations for each property
namespace properties {

// Base template struct for property traits
template<PropId id>
struct PropTraits;

""")

        for p in sorted(props_metadata):
            try:
                outfile.write(f"template<>\n")
                outfile.write(f"struct PropTraits<PropId::{get_prop_id(p)}> {{\n")
                md = props_metadata[p]
                types = md.get('type')
                if isinstance(types, str): # make it always a list
                    types = (types,)
                ctypes = {
                    "string": "const char *",
                    "enum": "const char *",
                    "int": "int",
                    "bool": "bool",
                    "double": "double",
                    "pointer": "const void *",
                }
                outfile.write(f"  using type = {ctypes[types[0]]};\n")
                is_multitype_bool = "true" if len(types) > 1 else "false"
                outfile.write(f"  static constexpr bool is_multitype = {is_multitype_bool};\n")
                outfile.write(f"  static constexpr const PropDef& def = prop_defs[static_cast<size_t>(PropId::{get_prop_id(p)})];\n")
                outfile.write("};\n") # end of prop traits
            except Exception as e:
                logging.error(f"Error: {p} is missing metadata? {e}")
                raise(e)

        outfile.write("} // namespace properties\n\n")
        # Generate static asserts to ensure our constants match the string values
        outfile.write("// Static asserts to check #define names vs. strings\n")
        for p in sorted(props_metadata):
            cname = get_cname(p, props_metadata)
            outfile.write(f"static_assert(std::string_view(\"{p}\") == std::string_view({cname}));\n")

        outfile.write("} // namespace OpenFX\n")



def gen_props_by_set(props_by_set, props_by_action, outfile_path: Path):
    """Generate a header file with definitions of all prop sets, including their props"""
    with open(outfile_path, 'w') as outfile:
        outfile.write(generated_source_header)
        outfile.write("""
#pragma once

#include <string>
#include <vector>
#include <map>
#include <array>
#include "ofxImageEffect.h"
#include "ofxGPURender.h"
#include "ofxColour.h"
#include "ofxDrawSuite.h"
#include "ofxParametricParam.h"
#include "ofxKeySyms.h"
#include "ofxPropsMetadata.h"
// #include "ofxOld.h"

namespace OpenFX {

struct Prop {
  const char *name;
  const PropDef &def; 
  bool host_write;
  bool plugin_write;
  bool host_optional;

  Prop(const char *n, const PropDef &d, bool hw, bool pw, bool ho)
       : name(n), def(d), host_write(hw), plugin_write(pw), host_optional(ho) {}
};

""")
        outfile.write("// Properties for property sets\n")
        outfile.write("static inline const std::map<const char *, std::vector<Prop>> prop_sets {\n")

        for pset in sorted(props_by_set.keys()):
            propdefs = []
            for p in props_for_set(pset, props_by_set, False):
                host_write = 'true' if p['write'] in ('host', 'all') else 'false'
                plugin_write = 'true' if p['write'] in ('plugin', 'all') else 'false'
                propdefs.append(f"{{ \"{p['name']}\", prop_defs[static_cast<size_t>(PropId::{get_prop_id(p['name'])})], {host_write}, {plugin_write}, false }}")
            propdefs_str = ",\n   ".join(propdefs)
            outfile.write(f"{{ \"{pset}\", {{ {propdefs_str} }} }},\n")
        outfile.write("};\n\n")

        actions = sorted(props_by_action.keys())

        outfile.write("// Actions\n")
        outfile.write(f"static inline const std::array<const char *, {len(actions)}> actions {{\n")
        for pset in actions:
            if not pset.startswith("kOfx"):
                pset = '"' + pset + '"'   # quote if it's not a known constant
            outfile.write(f"  {pset},\n")
        outfile.write("};\n\n")

        outfile.write("// Properties for action args\n")
        outfile.write("static inline const std::map<std::array<std::string_view, 2>, std::vector<const char *>> action_props {\n")
        for pset in actions:
            for subset in props_by_action[pset]:
                if not props_by_action[pset][subset]:
                    continue
                propnames = ",\n   ".join(sorted([f'"{p}"' for p in props_by_action[pset][subset]]))
                if not pset.startswith("kOfx"):
                    psetname = '"' + pset + '"'   # quote if it's not a known constant
                else:
                    psetname = pset
                outfile.write(f"{{ {{ {psetname}, \"{subset}\" }}, {{ {propnames} }} }},\n")

        outfile.write("};\n\n")

        outfile.write("// Static asserts for standard action names\n")
        for pset in actions:
            if not pset.startswith("Ofx"):
                continue
            outfile.write(f"static_assert(std::string_view(\"{pset}\") == std::string_view(k{pset}));\n")

        outfile.write("} // namespace OpenFX\n")


def main(args):
    script_dir = os.path.dirname(os.path.abspath(__file__))
    include_dir = Path(script_dir).parent / 'include'
    all_props = getPropertiesFromDir(include_dir)
    logging.info(f'Got {len(all_props)} props from "include" dir')

    with open(include_dir / 'ofx-props.yml', 'r') as props_file:
        props_data = yaml.safe_load(props_file)
    props_by_set = expand_set_props(props_data['propertySets'])
    props_by_action = props_data['Actions']
    props_metadata = props_data['properties']

    if args.verbose:
        print("\n=== Checking ofx-props.yml: should map 1:1 to props found in source/header files")
    errs = find_missing(all_props, props_metadata)
    if not errs and args.verbose:
        print(" ✔️ ALL OK")

    if args.verbose:
        print("\n=== Checking ofx-props.yml: every prop in a set should have metadata in the YML file")
    errs = check_props_by_set(props_by_set, props_by_action, props_metadata)
    if not errs and args.verbose:
        print(" ✔️ ALL OK")

    if args.verbose:
        print("\n=== Checking ofx-props.yml: every prop should be used in in at least one set in the YML file")
    errs = check_props_used_by_set(props_by_set, props_by_action, props_metadata)
    if not errs and args.verbose:
        print(" ✔️ ALL OK")

    if args.verbose:
        print(f"=== Generating {args.props_metadata}")
    gen_props_metadata(props_metadata, support_include_dir / args.props_metadata)

    if args.verbose:
        print(f"=== Generating props by set header {args.props_by_set}")
    gen_props_by_set(props_by_set, props_by_action, support_include_dir / args.props_by_set)

if __name__ == "__main__":
    script_dir = os.path.dirname(os.path.abspath(__file__))
    support_include_dir = Path(script_dir).parent / 'Support/include'
    parser = argparse.ArgumentParser(description="Check OpenFX properties and generate ancillary data structures",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Define arguments here
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode')
    parser.add_argument('--props-metadata', default=support_include_dir/"ofxPropsMetadata.h",
                        help="Generate property metadata into this file")
    parser.add_argument('--props-by-set', default=support_include_dir/"ofxPropsBySet.h",
                        help="Generate props by set metadata into this file")

    # Parse the arguments
    args = parser.parse_args()

    # Call the main function with parsed arguments
    main(args)
