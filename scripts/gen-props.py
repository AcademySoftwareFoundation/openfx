# Copyright OpenFX and contributors to the OpenFX project.
# SPDX-License-Identifier: BSD-3-Clause

# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "pyyaml>=1.0",
# ]
# ///

import os
import re
import sys
import difflib
import argparse
import yaml
import logging
from pathlib import Path
from collections.abc import Iterable

# Set up basic configuration for logging
logging.basicConfig(
    level=logging.INFO,  # Log level: DEBUG, INFO, WARNING, ERROR, CRITICAL
    format='%(levelname)s: %(message)s',  # Format of the log messages
    datefmt='%Y-%m-%d %H:%M:%S'  # Date format
)

# Global vars and config

generated_source_header = """// Copyright OpenFX and contributors to the OpenFX project.
// SPDX-License-Identifier: BSD-3-Clause
// NOTE: This file is auto-generated by gen-props.py. DO NOT EDIT.
"""


def getPropertiesFromFile(path):
    """Get all OpenFX property definitions from C header file.

    Uses a heuristic to identify property #define lines:
    anything starting with '#define' and containing 'Prop' in the name.
    """
    props = set()
    with open(path) as f:
        try:
            lines = f.readlines()
        except UnicodeDecodeError as e:
            logging.error(f'error reading {path}: {e}')
            raise e
        for l in lines:
            # Detect lines that correspond to a property definition, e.g:
            # #define kOfxPropLala "OfxPropLala"
            splits=l.split()
            if len(splits) < 3:
                continue
            if splits[0] != '#define':
                continue
            # ignore these
            nonProperties = ('kOfxPropertySuite',
                             # prop values, not props
                             'kOfxImageEffectPropColourManagementNone',
                             'kOfxImageEffectPropColourManagementBasic',
                             'kOfxImageEffectPropColourManagementCore',
                             'kOfxImageEffectPropColourManagementFull',
                             'kOfxImageEffectPropColourManagementOCIO',
                             )
            if splits[1] in nonProperties:
                continue
            # these are props, as well as anything with Prop in the name
            badlyNamedProperties = ("kOfxImageEffectFrameVarying",
                                    "kOfxImageEffectPluginRenderThreadSafety")
            if 'Prop' in splits[1] \
               or any(s in splits[1] for s in badlyNamedProperties):
                props.add(splits[1])
    return props

def getPropertiesFromDir(dir):
    """
    Recursively get all property definitions from source files in a dir.
    """

    extensions = {'.c', '.h', '.cxx', '.hxx', '.cpp', '.hpp'}

    props = set()
    for root, _dirs, files in os.walk(dir):
        for file in files:
            # Get the file extension
            file_extension = os.path.splitext(file)[1]

            if file_extension in extensions:
                file_path = os.path.join(root, file)
                props |= getPropertiesFromFile(file_path)
    return list(props)

def get_def(name: str, defs):
    if name.endswith('_REF'):
        defname = name.replace("_REF", "_DEF")
        return defs[defname]
    else:
        return [name]

def expand_set_props(props_by_set):
    """Expand refs in props_by_sets.
    YAML can't interpolate a list, so we do it here, using
    our own method:
    - A prop set may end with _DEF in which case it's just a definition
      containing a list of prop names.
    - A prop *name* may be <name>_REF which means to interpolate the
      corresponding DEF list into this set's props.
    Returns a new props_by_set with DEFs removed and all lists interpolated.
    """
    # First get all the list defs
    defs = {}
    sets = {}
    for key, value in props_by_set.items():
        if key.endswith('_DEF'):
            defs[key] = value   # should be a list to be interpolated
        else:
            sets[key] = value
    for key in sets:
        if not sets[key].get('props'):
            pass # do nothing, no expansion needed in inArgs/outArgs for now
        else:
            sets[key]['props'] = [item for element in sets[key]['props'] \
                         for item in get_def(element, defs)]
    return sets

def get_cname(propname, props_metadata):
    """Get the C `#define` name for a property name.

    Look up the special cname in props_metadata, or in the normal
    case just prepend "k".
    """
    return props_metadata[propname].get('cname', "k" + propname)

def get_prop_id(propname):
    """HACK ALERT: a few props' names (string values) start with k.
    Those are also the #define names. If we use those as PropId enum
    values, they'll get expanded into the strings which will lead to
    compile errors. This means the names to be looked up always don't
    have the "k". We could prefix them or something but this should be
    OK. """
    if propname.startswith("k"):
        return propname[1:]
    return propname

def find_stringname(cname, props_metadata):
    """Try to find the actual string corresponding to the C #define name.
    This may be slow; looks through all the metadata for a matching
    "cname", otherwise strips "k".
    """
    for p in props_metadata:
        if props_metadata[p].get('cname') == cname:
            return p
    if cname.startswith("k"):
        return cname[1:]
    return "unknown-stringname-for-" + cname

def find_missing(all_props, props_metadata):
    """Find and print all mismatches between prop defs and metadata.

    Returns 0 if no errors.
    """
    errs = 0
    for p in sorted(all_props): # constants from #include files, with "k" prefix
        stringval = find_stringname(p, props_metadata)
        if not props_metadata.get(stringval):
            logging.error(f"No YAML metadata found for {p}")
            errs += 1
    for p in sorted(props_metadata):
        cname = get_cname(p, props_metadata)
        if cname not in all_props:
            logging.error(f"No prop definition found for '{p}' in source/include")
            matches = difflib.get_close_matches(p, all_props, 3, 0.9)
            if matches:
                logging.info(f" Did you mean: {matches}")
            errs += 1
    return errs

def props_for_set(pset, props_by_set, name_only=True):
    """Generator yielding all props for the given prop set (not used for actions).
    This implements the options override scheme, parsing the prop name etc.
    If not name_only, yields a dict of name and other options.
    """
    if not props_by_set[pset].get('props'):
        return
    # All the default options for this propset. Merged into each prop.
    propset_options = props_by_set[pset].copy()
    propset_options.pop('props', None)
    for p in props_by_set[pset]['props']:
        # Parse p, of form NAME | key=value,key=value
        pattern = r'^\s*(\w+)\s*\|\s*([\w\s,=]*)$'
        match = re.match(pattern, p)
        if not match:
            if name_only:
                yield p
            else:
                yield {**propset_options, **{"name": p}}
            continue
        name = match.group(1)
        if name_only:
            yield name
        else:
            # parse key/value pairs, apply defaults, and include name
            key_values_str = match.group(2)
            if not key_values_str:
                options = {}
            else:
                key_value_pattern = r'(\w+)=([\w-]+)'
                options = dict(re.findall(key_value_pattern, key_values_str))
            yield {**propset_options, **options, **{"name": name}}

def check_props_by_set(props_by_set, props_by_action, props_metadata):
    """Find and print all mismatches between prop set specs, props, and metadata.

    * Each prop name in props_by_set should have a match in props_metadata
    Note that props_by_pset may have multiple levels, e.g. inArgs for an action.
    Returns 0 if no errors.
    """
    errs = 0
    for pset in sorted(props_by_set):
        for p in props_for_set(pset, props_by_set):
            if not props_metadata.get(p):
                logging.error(f"No props metadata found for {pset}.{p}")
                errs += 1
    for pset in sorted(props_by_action):
        # For actions, the value of props_by_set[pset] is a dict, each
        # (e.g. inArgs, outArgs) containing a list of props.
        for subset in sorted(props_by_action[pset]):
            if not props_by_action[pset][subset]:
                continue
            for p in props_by_action[pset][subset]:
                if not props_metadata.get(p):
                    logging.error(f"No props metadata found for action {pset}.{subset}.{p}")
                    errs += 1
    return errs

def check_props_used_by_set(props_by_set, props_by_action, props_metadata):
    """Find and print all mismatches between prop set specs, props, and metadata.

    * Each prop name in props_metadata should be used in at least one set.
    Returns 0 if no errors.
    """
    errs = 0
    for prop in props_metadata:
        found = 0
        for pset in props_by_set:
            for set_prop in props_for_set(pset, props_by_set):
                if set_prop == prop:
                    found += 1
        for pset in props_by_action:
            # inArgs/outArgs
            for subset in sorted(props_by_action[pset]):
                if not props_by_action[pset][subset]:
                    continue
                for set_prop in props_by_action[pset][subset]:
                    if set_prop == prop:
                        found += 1
        if not found and not props_metadata[prop].get('deprecated'):
            logging.error(f"Prop {prop} not used in any prop set in YML file")
    return errs

def gen_props_metadata(props_metadata, outfile_path: Path):
    """Generate a header file with metadata for each prop"""
    with open(outfile_path, 'w') as outfile:
        outfile.write(generated_source_header)
        outfile.write("""
#pragma once

#include <array>
#include <string_view>

#include <ofxImageEffect.h>
#include <ofxGPURender.h>
#include <ofxColour.h>
#include <ofxDrawSuite.h>
#include <ofxParametricParam.h>
#include <ofxKeySyms.h>
#include <ofxOld.h>

#include "ofxSpan.h"

namespace openfx {
enum class PropType {
   Int,
   Double,
   Enum,
   Bool,
   String,
   Pointer
};

// Each prop has a PropId::<propname> enum, a runtime-accessible PropDef struct, and a compile-time PropTraits<id>.
// These can be used by Support/include/PropsAccess.h for type-safe property access.

""")
        outfile.write(f"//Property ID enum for compile-time lookup and type safety\n")
        outfile.write(f"enum class PropId {{\n")
        id = 0
        for p in sorted(props_metadata):
            pname = get_prop_id(p)
            orig_name_msg = ''
            if pname != p:
                orig_name_msg = f" (orig name: {pname})"
            outfile.write(f"  {pname}, // {id}{orig_name_msg}\n")
            id += 1
        outfile.write(f"  NProps // {id}\n")
        outfile.write("}; // PropId\n\n")

        # Property enum values (for enums only)

        outfile.write("// Separate arrays for enum-values for enum props, to keep everything constexpr\n")
        outfile.write("namespace prop_enum_values {\n")
        for p in sorted(props_metadata):
            md = props_metadata[p]
            if md['type'] == 'enum':
                values = "{" + ",".join(f'\"{v}\"' for v in md['values']) + "}"
                outfile.write(f"constexpr std::array {p} =\n  {values};\n")
        outfile.write("} // namespace prop_enum_values\n");

        # Property definitions

        outfile.write("""

// Property type arrays for spans (generated before PropDef)
namespace prop_type_arrays {
""")
        # Generate type arrays for each property
        for p in sorted(props_metadata):
            md = props_metadata[p]
            types = md.get('type')
            if isinstance(types, str):
                types = (types,)
            prop_type_defs = "{" + ",".join(f'PropType::{t.capitalize()}' for t in types) + "}"
            outfile.write(f"static constexpr PropType {p}_types[] = {prop_type_defs};\n")
        outfile.write("} // namespace prop_type_arrays\n\n")

        outfile.write("""
struct PropDef {
   const char* name;                    // Property name
   openfx::span<const PropType> supportedTypes; // Supported data types
   int dimension;                       // Property dimension (0 for variable)
   openfx::span<const char* const> enumValues;  // Valid values for enum properties
};

// Array type for storing all PropDefs, indexed by PropId for simplicity
template <typename T, PropId MaxValue = PropId::NProps>
struct PropDefsArray {
    static constexpr size_t Size = static_cast<size_t>(MaxValue);
    std::array<T, Size> data;

    // constexpr T& operator[](PropId index) {
    //   return data[static_cast<size_t>(index)];
    // }

    constexpr const T& operator[](PropId index) const {
        return data[static_cast<size_t>(index)];
    }
    constexpr const T& operator[](size_t index) const {
        return data[index];
    }
};

// Property definitions
static inline constexpr PropDefsArray<PropDef> prop_defs = {
  {{
""")

        for p in sorted(props_metadata):
            try:
                # name (id field removed - it was never used)
                prop_def = f"{{ \"{p}\",\n  "
                md = props_metadata[p]
                types = md.get('type')
                if isinstance(types, str): # make it always a list
                    types = (types,)
                # types - use span pointing to type array
                type_count = len(types)
                prop_def += f"openfx::span(prop_type_arrays::{p}_types, {type_count}), "
                # dimension
                prop_def += f"{md['dimension']}, "
                # enum values - use span
                if md['type'] == 'enum':
                    assert isinstance(md['values'], list)
                    prop_def += f"openfx::span(prop_enum_values::{p}.data(), prop_enum_values::{p}.size())"
                else:
                    prop_def += "openfx::span<const char* const>()"
                prop_def += "},\n"
                outfile.write(prop_def)
            except Exception as e:
                logging.error(f"Error: {p} is missing metadata? {e}")
                raise(e)
        outfile.write(" }}\n};\n\n")

        outfile.write("""
//Template specializations for each property
namespace properties {

// Base template struct for property traits
template<PropId id>
struct PropTraits;

#define DEFINE_PROP_TRAITS(id, _type, _is_multitype) \\
template<> \\
struct PropTraits<PropId::id> { \\
    using type = _type; \\
    static constexpr bool is_multitype = _is_multitype; \\
    static constexpr const PropDef& def = prop_defs[PropId::id]; \\
}

""")

        for p in sorted(props_metadata):
            try:
                md = props_metadata[p]
                types = md.get('type')
                if isinstance(types, str): # make it always a list
                    types = (types,)
                ctypes = {
                    "string": "const char *",
                    "enum": "const char *",
                    "int": "int",
                    "bool": "bool",
                    "double": "double",
                    "pointer": "void *",
                }
                is_multitype_bool = "true" if len(types) > 1 else "false"
                outfile.write(f"DEFINE_PROP_TRAITS({get_prop_id(p)}, {ctypes[types[0]]}, {is_multitype_bool});\n")
            except Exception as e:
                logging.error(f"Error: {p} is missing metadata? {e}")
                raise(e)

        outfile.write("} // namespace properties\n\n")
        # Generate static asserts to ensure our constants match the string values
        outfile.write("// Static asserts to check #define names vs. strings\n")
        outfile.write("namespace assertions {\nusing std::string_view;\n\n")
        for p in sorted(props_metadata):
            cname = get_cname(p, props_metadata)
            outfile.write(f"static_assert(string_view(\"{p}\") == string_view({cname}));\n")

        outfile.write("} // namespace assertions\n")
        outfile.write("} // namespace openfx\n")



def gen_props_by_set(props_by_set, props_by_action, outfile_path: Path):
    """Generate a header file with definitions of all prop sets, including their props"""
    with open(outfile_path, 'w') as outfile:
        outfile.write(generated_source_header)
        outfile.write("""
#pragma once

#include <string>
#include <vector>
#include <map>
#include <array>
#include <ofxImageEffect.h>
#include <ofxGPURender.h>
#include <ofxColour.h>
#include <ofxDrawSuite.h>
#include <ofxParametricParam.h>
#include <ofxKeySyms.h>
#include "ofxPropsMetadata.h"
// #include <ofxOld.h>

namespace openfx {

struct Prop {
  const char *name;
  const PropDef &def; 
  bool host_write;
  bool plugin_write;
  bool host_optional;

  Prop(const char *n, const PropDef &d, bool hw, bool pw, bool ho)
       : name(n), def(d), host_write(hw), plugin_write(pw), host_optional(ho) {}
};

""")
        outfile.write("// Properties for property sets\n")
        outfile.write("static inline const std::map<const char *, std::vector<Prop>> prop_sets {\n")

        for pset in sorted(props_by_set.keys()):
            propdefs = []
            for p in props_for_set(pset, props_by_set, False):
                host_write = 'true' if p['write'] in ('host', 'all') else 'false'
                plugin_write = 'true' if p['write'] in ('plugin', 'all') else 'false'
                propdefs.append(f"{{ \"{p['name']}\", prop_defs[PropId::{get_prop_id(p['name'])}], {host_write}, {plugin_write}, false }}")
            propdefs_str = ",\n   ".join(propdefs)
            outfile.write(f"// {pset}\n{{ \"{pset}\", {{\n   {propdefs_str} }} }},\n")
        outfile.write("};\n\n")

        actions = sorted(props_by_action.keys())

        outfile.write("// Actions\n")
        outfile.write(f"static inline const std::array<const char *, {len(actions)}> actions {{\n")
        for pset in actions:
            if not pset.startswith("kOfx"):
                pset = '"' + pset + '"'   # quote if it's not a known constant
            outfile.write(f"  {pset},\n")
        outfile.write("};\n\n")

        outfile.write("// Properties for action args\n")
        outfile.write("static inline const std::map<std::array<std::string_view, 2>, std::vector<const char *>> action_props {\n")
        for pset in actions:
            for subset in props_by_action[pset]:
                if not props_by_action[pset][subset]:
                    continue
                propnames = ",\n    ".join(sorted([f'"{p}"' for p in props_by_action[pset][subset]]))
                if not pset.startswith("kOfx"):
                    psetname = '"' + pset + '"'   # quote if it's not a known constant
                else:
                    psetname = pset
                outfile.write(f"// {pset}.{subset}\n")
                outfile.write(f"{{ {{ {psetname}, \"{subset}\" }},\n  {{ {propnames} }} }},\n")

        outfile.write("};\n\n")

        outfile.write("// Static asserts for standard action names\n")
        for pset in actions:
            if not pset.startswith("Ofx"):
                continue
            outfile.write(f"static_assert(std::string_view(\"{pset}\") == std::string_view(k{pset}));\n")

        outfile.write("} // namespace openfx\n")


def gen_propset_accessors(props_by_set, props_metadata, outfile_path: Path, for_host=False):
    """Generate type-safe accessor classes for each property set.

    Args:
        for_host: If True, generate host accessors (setters for host_write, getters for plugin_write).
                  If False, generate plugin accessors (getters for host_write, setters for plugin_write).
    """

    def get_prop_id(propname):
        """Get PropId enum name from property name."""
        if propname.startswith('k'):
            # kOfxParamPropUseHostOverlayHandle -> OfxParamPropUseHostOverlayHandle
            return propname[1:]
        return propname

    def prop_to_method_name(propname):
        """Convert property name to method name."""
        # Strip prefixes: OfxPropLabel -> Label, OfxImageEffectPropContext -> Context
        name = propname
        if name.startswith('Ofx'):
            # Remove Ofx prefix
            name = name[3:]
            # Remove category prefixes like ImageEffect, ImageClip, Param, etc.
            for prefix in ['ImageEffect', 'ImageClip', 'Param', 'Image', 'Plugin', 'OpenGL']:
                if name.startswith(prefix + 'Prop'):
                    name = name[len(prefix) + 4:]  # +4 for "Prop"
                    break
            else:
                # Just remove Prop if it's there
                if name.startswith('Prop'):
                    name = name[4:]
        elif name.startswith('kOfx'):
            # Handle kOfxParamPropUseHostOverlayHandle -> UseHostOverlayHandle
            name = name[1:]  # Remove 'k'
            name = prop_to_method_name(name)  # Recursive call

        # Convert first letter to lowercase for getter
        if name:
            name = name[0].lower() + name[1:]
        return name

    def get_cpp_type(prop_def, include_array=True):
        """Get C++ type for a property."""
        types = prop_def.get('type')
        if isinstance(types, str):
            types = [types]

        dimension = prop_def['dimension']

        # Map OpenFX types to C++ types
        type_map = {
            'string': 'const char*',
            'int': 'int',
            'double': 'double',
            'pointer': 'void*',
            'bool': 'bool',
            'enum': 'const char*'
        }

        cpp_type = type_map.get(types[0], 'void*')

        # If dimension > 1, return array type
        if include_array and dimension > 1:
            return f'std::array<{cpp_type}, {dimension}>'

        return cpp_type

    with open(outfile_path, 'w') as outfile:
        outfile.write(generated_source_header)
        target = "HOST" if for_host else "PLUGIN"
        outfile.write(f"""
#pragma once

#include <array>
#include <vector>
#include "ofxPropsAccess.h"
#include "ofxPropsMetadata.h"

namespace openfx {{

// Type-safe property set accessor classes for {target}S
//
// These wrapper classes provide convenient, type-safe access to property sets.
// - For plugins: getters for host-written properties, setters for plugin-written properties
// - For hosts: setters for host-written properties, getters for plugin-written properties
//
// Usage:
//   PropertyAccessor accessor(handle, propSuite);
//   EffectDescriptor desc(accessor);
//   desc.setLabel("My Effect");  // Type-safe setter
//   auto label = desc.label();    // Type-safe getter

// Base class for property set accessors
class PropertySetAccessor {{
protected:
    PropertyAccessor& props_;
public:
    explicit PropertySetAccessor(PropertyAccessor& p) : props_(p) {{}}

    // Access to underlying PropertyAccessor for advanced use
    PropertyAccessor& props() {{ return props_; }}
    const PropertyAccessor& props() const {{ return props_; }}
}};

""")

        # Generate a class for each property set
        for pset_name in sorted(props_by_set.keys()):
            # Derive class name from property set name
            class_name = pset_name.replace(' ', '')

            outfile.write(f"// Property set accessor for: {pset_name}\n")
            outfile.write(f"class {class_name} : public PropertySetAccessor {{\n")
            outfile.write("public:\n")
            outfile.write(f"    using PropertySetAccessor::PropertySetAccessor;\n\n")

            # Track which methods we've generated to avoid duplicates
            generated_methods = set()

            # Generate methods for each property
            for prop in props_for_set(pset_name, props_by_set, name_only=False):
                propname = prop['name']
                write_access = prop['write']

                # Get property metadata
                if propname not in props_metadata:
                    continue

                prop_def = props_metadata[propname]
                method_name = prop_to_method_name(propname)
                prop_id = get_prop_id(propname)

                # Skip if we've already generated this method
                if method_name in generated_methods:
                    continue
                generated_methods.add(method_name)

                # Check if this is a multi-type property
                types = prop_def.get('type')
                if isinstance(types, str):
                    types = [types]
                is_multitype = len(types) > 1

                dimension = prop_def['dimension']
                cpp_type = get_cpp_type(prop_def, include_array=False) if not is_multitype else None

                # Determine what to generate based on for_host flag
                # For plugins: getters for host-written, setters for plugin-written
                # For hosts: setters for host-written, getters for plugin-written
                generate_getter = False
                generate_setter = False

                if for_host:
                    # Host accessors: host sets, host reads plugin-written
                    if write_access in ('host', 'all'):
                        generate_setter = True
                    if write_access in ('plugin', 'all'):
                        generate_getter = True
                else:
                    # Plugin accessors: plugin reads host-written, plugin sets
                    if write_access in ('host', 'all'):
                        generate_getter = True
                    if write_access in ('plugin', 'all'):
                        generate_setter = True

                # Generate getter
                if generate_getter:
                    if is_multitype:
                        # Multi-type property - generate templated getter
                        outfile.write(f"    // Multi-type property (supports: {', '.join(types)})\n")
                        outfile.write(f"    template<typename T>\n")
                        if dimension == 1:
                            # Dimension 1: exactly one value, no index needed
                            outfile.write(f"    T {method_name}() const {{\n")
                            outfile.write(f"        return props_.get<PropId::{prop_id}, T>(0);\n")
                        else:
                            # Dimension 0 or > 1: include index parameter
                            outfile.write(f"    T {method_name}(int index = 0) const {{\n")
                            outfile.write(f"        return props_.get<PropId::{prop_id}, T>(index);\n")
                        outfile.write(f"    }}\n\n")

                        # Also provide getAll for multi-type (returns vector)
                        if dimension != 1:  # dimension 0 or > 1
                            outfile.write(f"    template<typename T>\n")
                            outfile.write(f"    std::vector<T> {method_name}All() const {{\n")
                            outfile.write(f"        return props_.getAll<PropId::{prop_id}, T>();\n")
                            outfile.write(f"    }}\n\n")
                    else:
                        # Single-type property
                        if dimension == 1:
                            # Dimension 1: exactly one value, no index needed
                            outfile.write(f"    {cpp_type} {method_name}() const {{\n")
                            outfile.write(f"        return props_.get<PropId::{prop_id}>(0);\n")
                            outfile.write(f"    }}\n\n")
                        elif dimension == 0:
                            # Dimension 0: variable dimension, include index
                            outfile.write(f"    {cpp_type} {method_name}(int index = 0) const {{\n")
                            outfile.write(f"        return props_.get<PropId::{prop_id}>(index);\n")
                            outfile.write(f"    }}\n\n")
                        else:
                            # Dimension > 1: array getter
                            array_type = get_cpp_type(prop_def, include_array=True)
                            outfile.write(f"    {array_type} {method_name}() const {{\n")
                            outfile.write(f"        return props_.getAll<PropId::{prop_id}>();\n")
                            outfile.write(f"    }}\n\n")

                # Generate setter
                if generate_setter:
                    setter_name = 'set' + method_name[0].upper() + method_name[1:]

                    if is_multitype:
                        # Multi-type property - generate templated setter
                        outfile.write(f"    // Multi-type property (supports: {', '.join(types)})\n")
                        outfile.write(f"    template<typename T>\n")
                        if dimension == 1:
                            # Dimension 1: exactly one value, no index needed
                            outfile.write(f"    void {setter_name}(T value) {{\n")
                            outfile.write(f"        props_.set<PropId::{prop_id}, T>(value, 0);\n")
                        else:
                            # Dimension 0 or > 1: include index parameter
                            outfile.write(f"    void {setter_name}(T value, int index = 0) {{\n")
                            outfile.write(f"        props_.set<PropId::{prop_id}, T>(value, index);\n")
                        outfile.write(f"    }}\n\n")

                        # Also provide setAll for multi-type
                        if dimension != 1:  # dimension 0 or > 1
                            outfile.write(f"    template<typename T>\n")
                            outfile.write(f"    void {setter_name}All(const std::vector<T>& values) {{\n")
                            outfile.write(f"        props_.setAll<PropId::{prop_id}, T>(values);\n")
                            outfile.write(f"    }}\n\n")
                    else:
                        # Single-type property
                        if dimension == 1:
                            # Dimension 1: exactly one value, no index needed
                            outfile.write(f"    void {setter_name}({cpp_type} value) {{\n")
                            outfile.write(f"        props_.set<PropId::{prop_id}>(value, 0);\n")
                            outfile.write(f"    }}\n\n")
                        elif dimension == 0:
                            # Dimension 0: variable dimension, include index
                            outfile.write(f"    void {setter_name}({cpp_type} value, int index = 0) {{\n")
                            outfile.write(f"        props_.set<PropId::{prop_id}>(value, index);\n")
                            outfile.write(f"    }}\n\n")
                        else:
                            # Dimension > 1: array setter
                            array_type = get_cpp_type(prop_def, include_array=True)
                            outfile.write(f"    void {setter_name}(const {array_type}& values) {{\n")
                            outfile.write(f"        props_.setAll<PropId::{prop_id}>(values);\n")
                            outfile.write(f"    }}\n\n")

            outfile.write("};\n\n")

        outfile.write("} // namespace openfx\n")


def main(args):
    script_dir = os.path.dirname(os.path.abspath(__file__))
    include_dir = Path(script_dir).parent / 'include'
    all_props = getPropertiesFromDir(include_dir)
    logging.info(f'Got {len(all_props)} props from "include" dir')

    with open(include_dir / 'ofx-props.yml', 'r') as props_file:
        props_data = yaml.safe_load(props_file)
    props_by_set = expand_set_props(props_data['propertySets'])
    props_by_action = props_data['Actions']
    props_metadata = props_data['properties']

    if args.verbose:
        print("\n=== Checking ofx-props.yml: should map 1:1 to props found in source/header files")
    errs = find_missing(all_props, props_metadata)
    if not errs and args.verbose:
        print(" ✔️ ALL OK")

    if args.verbose:
        print("\n=== Checking ofx-props.yml: every prop in a set should have metadata in the YML file")
    errs = check_props_by_set(props_by_set, props_by_action, props_metadata)
    if not errs and args.verbose:
        print(" ✔️ ALL OK")

    if args.verbose:
        print("\n=== Checking ofx-props.yml: every prop should be used in in at least one set in the YML file")
    errs = check_props_used_by_set(props_by_set, props_by_action, props_metadata)
    if not errs and args.verbose:
        print(" ✔️ ALL OK")

    if args.verbose:
        print(f"=== Generating {args.props_metadata}")
    gen_props_metadata(props_metadata, dest_path / args.props_metadata)

    if args.verbose:
        print(f"=== Generating props by set header {args.props_by_set}")
    gen_props_by_set(props_by_set, props_by_action, dest_path / args.props_by_set)

    if args.verbose:
        print(f"=== Generating property set accessor classes for plugins: {args.propset_accessors}")
    gen_propset_accessors(props_by_set, props_metadata, dest_path / args.propset_accessors, for_host=False)

    if args.verbose:
        print(f"=== Generating property set accessor classes for hosts: {args.propset_accessors_host}")
    gen_propset_accessors(props_by_set, props_metadata, dest_path / args.propset_accessors_host, for_host=True)

if __name__ == "__main__":
    script_dir = os.path.dirname(os.path.abspath(__file__))
    dest_path = Path(script_dir).parent / 'openfx-cpp/include/openfx'
    parser = argparse.ArgumentParser(description="Check OpenFX properties and generate ancillary data structures",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Define arguments here
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode')
    parser.add_argument('--props-metadata', default=dest_path/"ofxPropsMetadata.h",
                        help="Generate property metadata into this file")
    parser.add_argument('--props-by-set', default=dest_path/"ofxPropsBySet.h",
                        help="Generate props by set metadata into this file")
    parser.add_argument('--propset-accessors', default=dest_path/"ofxPropSetAccessors.h",
                        help="Generate property set accessor classes for plugins into this file")
    parser.add_argument('--propset-accessors-host', default=dest_path/"ofxPropSetAccessorsHost.h",
                        help="Generate property set accessor classes for hosts into this file")

    # Parse the arguments
    args = parser.parse_args()

    # Call the main function with parsed arguments
    main(args)
